#
# unicoderanges_v1.py
#
# Copyright Â© 2004-2013, 2015-2016 Monotype Imaging Inc. All Rights Reserved.
#

"""
Support for representations of Unicode coverage data for Version 1 OS/2 tables.
"""

# System imports
import itertools

# Other imports
from fontio3 import utilities
from fontio3.fontdata import maskmeta
from fontio3.utilities import span

# -----------------------------------------------------------------------------

#
# Private constants
#

f = span.Span.fromstringhex

# The following is (mostly) mechanically generated by _generateUnicodeRanges_v1.py
_rangeData = {
    0: (100, f('0x20-0x7E')),
    1: (None, f('0xA0-0xFF')),
    2: (None, f('0x100-0x17F')),
    3: (None, f('0x180-0x24F')),
    4: (None, f('0x250-0x2AF')),
    5: (None, f('0x2B0-0x2FF')),
    6: (None, f('0x300-0x36F')),
    7: (None, f('0x370-0x377, 0x37A-0x37F, 0x384-0x38A, 0x38C, 0x38E-0x3A1, 0x3A3-0x3D7')),
    8: (None, f('0x3DA-0x3FF')),
    9: (None, f('0x400-0x4FF')),
   10: (None, f('0x531-0x556, 0x559-0x55F, 0x561-0x587, 0x589-0x58A, 0x58D-0x58F')),
   11: (None, f('0x5B0-0x5C7, 0x5D0-0x5EA')),
   12: (None, f('0x591-0x5AF, 0x5F0-0x5F4')),
   13: (None, f('0x600-0x61C, 0x61E-0x670')),
   14: (None, f('0x671-0x6FF')),
   15: (None, f('0x900-0x97F')),
   16: (None, f('0x980-0x983, 0x985-0x98C, 0x98F-0x990, 0x993-0x9A8, 0x9AA-0x9B0, 0x9B2, 0x9B6-0x9B9, 0x9BC-0x9C4, 0x9C7-0x9C8, 0x9CB-0x9CE, 0x9D7, 0x9DC-0x9DD, 0x9DF-0x9E3, 0x9E6-0x9FB')),
   17: (None, f('0xA01-0xA03, 0xA05-0xA0A, 0xA0F-0xA10, 0xA13-0xA28, 0xA2A-0xA30, 0xA32-0xA33, 0xA35-0xA36, 0xA38-0xA39, 0xA3C, 0xA3E-0xA42, 0xA47-0xA48, 0xA4B-0xA4D, 0xA51, 0xA59-0xA5C, 0xA5E, 0xA66-0xA75')),
   18: (None, f('0xA81-0xA83, 0xA85-0xA8D, 0xA8F-0xA91, 0xA93-0xAA8, 0xAAA-0xAB0, 0xAB2-0xAB3, 0xAB5-0xAB9, 0xABC-0xAC5, 0xAC7-0xAC9, 0xACB-0xACD, 0xAD0, 0xAE0-0xAE3, 0xAE6-0xAF1, 0xAF9')),
   19: (None, f('0xB01-0xB03, 0xB05-0xB0C, 0xB0F-0xB10, 0xB13-0xB28, 0xB2A-0xB30, 0xB32-0xB33, 0xB35-0xB39, 0xB3C-0xB44, 0xB47-0xB48, 0xB4B-0xB4D, 0xB56-0xB57, 0xB5C-0xB5D, 0xB5F-0xB63, 0xB66-0xB77')),
   20: (None, f('0xB82-0xB83, 0xB85-0xB8A, 0xB8E-0xB90, 0xB92-0xB95, 0xB99-0xB9A, 0xB9C, 0xB9E-0xB9F, 0xBA3-0xBA4, 0xBA8-0xBAA, 0xBAE-0xBB9, 0xBBE-0xBC2, 0xBC6-0xBC8, 0xBCA-0xBCD, 0xBD0, 0xBD7, 0xBE6-0xBFA')),
   21: (None, f('0xC00-0xC03, 0xC05-0xC0C, 0xC0E-0xC10, 0xC12-0xC28, 0xC2A-0xC39, 0xC3D-0xC44, 0xC46-0xC48, 0xC4A-0xC4D, 0xC55-0xC56, 0xC58-0xC5A, 0xC60-0xC63, 0xC66-0xC6F, 0xC78-0xC7F')),
   22: (None, f('0xC81-0xC83, 0xC85-0xC8C, 0xC8E-0xC90, 0xC92-0xCA8, 0xCAA-0xCB3, 0xCB5-0xCB9, 0xCBC-0xCC4, 0xCC6-0xCC8, 0xCCA-0xCCD, 0xCD5-0xCD6, 0xCDE, 0xCE0-0xCE3, 0xCE6-0xCEF, 0xCF1-0xCF2')),
   23: (None, f('0xD01-0xD03, 0xD05-0xD0C, 0xD0E-0xD10, 0xD12-0xD3A, 0xD3D-0xD44, 0xD46-0xD48, 0xD4A-0xD4E, 0xD57, 0xD5F-0xD63, 0xD66-0xD75, 0xD79-0xD7F')),
   24: (None, f('0xE01-0xE3A, 0xE3F-0xE5B')),
   25: (None, f('0xE81-0xE82, 0xE84, 0xE87-0xE88, 0xE8A, 0xE8D, 0xE94-0xE97, 0xE99-0xE9F, 0xEA1-0xEA3, 0xEA5, 0xEA7, 0xEAA-0xEAB, 0xEAD-0xEB9, 0xEBB-0xEBD, 0xEC0-0xEC4, 0xEC6, 0xEC8-0xECD, 0xED0-0xED9, 0xEDC-0xEDF')),
   26: (None, f('0x10D0-0x10F0, 0x10FB')),
   27: (None, f('0x10F1-0x10F6')),
   28: (None, f('0x1100-0x11FF')),
   29: (None, f('0x1E00-0x1EFF')),
   30: (None, f('0x1F00-0x1F15, 0x1F18-0x1F1D, 0x1F20-0x1F45, 0x1F48-0x1F4D, 0x1F50-0x1F57, 0x1F59, 0x1F5B, 0x1F5D, 0x1F5F-0x1F7D, 0x1F80-0x1FB4, 0x1FB6-0x1FC4, 0x1FC6-0x1FD3, 0x1FD6-0x1FDB, 0x1FDD-0x1FEF, 0x1FF2-0x1FF4, 0x1FF6-0x1FFE')),
   31: (None, f('0x2000-0x2064, 0x2066-0x206F')),
   32: (None, f('0x2070-0x2071, 0x2074-0x208E, 0x2090-0x209C')),
   33: (None, f('0x20A0-0x20BE')),
   34: (None, f('0x20D0-0x20F0')),
   35: (None, f('0x2100-0x214F')),
   36: (None, f('0x2150-0x218B')),
   37: (None, f('0x2190-0x21FF')),
   38: (None, f('0x2200-0x22FF')),
   39: (None, f('0x2300-0x23FA')),
   40: (None, f('0x2400-0x2426')),
   41: (None, f('0x2440-0x244A')),
   42: (None, f('0x2460-0x24FF')),
   43: (None, f('0x2500-0x257F')),
   44: (None, f('0x2580-0x259F')),
   45: (None, f('0x25A0-0x25FF')),
   46: (None, f('0x2600-0x26FF')),
   47: (None, f('0x2700-0x27BF')),
   48: (None, f('0x3000-0x303F')),
   49: (None, f('0x3041-0x3096, 0x3099-0x309F')),
   50: (None, f('0x30A0-0x30FF')),
   51: (None, f('0x3105-0x312D')),
   52: (None, f('0x3131-0x318E')),
   53: (None, f('0x3190-0x319F')),
   54: (None, f('0x3200-0x321E, 0x3220-0x32FE')),
   55: (None, f('0x3300-0x33FF')),
   56: (None, f('0xAC00-0xD7A3')),
   59: (1, f('0x4E00-0x9FD5')),
   60: (0, f('0xE000-0xF8FF')),
   61: (None, f('0xF900-0xFA6D, 0xFA70-0xFAD9')),
   62: (None, f('0xFB00-0xFB06, 0xFB13-0xFB17, 0xFB1D-0xFB36, 0xFB38-0xFB3C, 0xFB3E, 0xFB40-0xFB41, 0xFB43-0xFB44, 0xFB46-0xFB4F')),
   63: (None, f('0xFB50-0xFBC1, 0xFBD3-0xFD3F, 0xFD50-0xFD8F, 0xFD92-0xFDC7, 0xFDF0-0xFDFD')),
   64: (None, f('0xFE20-0xFE2F')),
   65: (None, f('0xFE30-0xFE4F')),
   66: (None, f('0xFE50-0xFE52, 0xFE54-0xFE66, 0xFE68-0xFE6B')),
   67: (None, f('0xFE70-0xFE74, 0xFE76-0xFEFC, 0xFEFF')),
   68: (None, f('0xFF01-0xFFBE, 0xFFC2-0xFFC7, 0xFFCA-0xFFCF, 0xFFD2-0xFFD7, 0xFFDA-0xFFDC, 0xFFE0-0xFFE6, 0xFFE8-0xFFEE')),
   69: (None, f('0xFFF9-0xFFFD')),
   }

del f

# -----------------------------------------------------------------------------

#
# Private functions
#

def _recalc(key, oldValue, **kwArgs):
    override, r = _rangeData[key]
    threshold = kwArgs.pop('threshold', (10 if override is None else override))
    
    if 'unicodeSpan' in kwArgs:
        uSpan = kwArgs['unicodeSpan']
    
    else:
        editor = kwArgs['editor']
        
        if editor is None:
            raise NoEditor()
        
        if not editor.reallyHas(b'cmap'):
            raise NoCmap()
        
        uMap = editor.cmap.getUnicodeMap()
        
        if not len(uMap):
            uMap = editor.cmap.getSymbolMap()
        
        uSpan = span.Span(uMap)
    
    this = r.copy()
    this.intersectSpan(uSpan)
    rCount = r.count()
    thisCount = this.count()
    
    if threshold == 0:
        newValue = bool(thisCount)
    
    elif threshold == 100:
        newValue = thisCount == rCount
    
    else:
        presentRatio = float(thisCount) / float(rCount)
        newValue = presentRatio >= (threshold / 100.0)
    
    return newValue != oldValue, newValue

def _validate(obj, **kwArgs):
    d = obj.__dict__
    logger = kwArgs['logger']
    editor = kwArgs['editor']
    
    if (editor is None) or (not editor.reallyHas(b'cmap')):
        logger.error((
          'V0553',
          (),
          "Unable to validate Unicode ranges, because the Editor and/or "
          "Cmap are missing or empty."))
        
        return False
    
    uMap = editor.cmap.getUnicodeMap()
    
    if not len(uMap):
        uMap = editor.cmap.getSymbolMap()
    
    uSpan = span.Span(uMap)
    kwArgs['threshold'] = 0
    obj2 = obj.recalculated(unicodeSpan=uSpan, **kwArgs)
    d2 = obj2.__dict__
    r = True
    
    for rangeID, key in obj.rangeIDToName.items():
        if d[key] and (not d2[key]):
            logger.error((
              'E2113',
              (key,),
              "Unicode range %r claimed to be present but is not."))
            
            r = False
        
        elif d2[key] and (not d[key]):
            logger.warning((
              'V0795',
              (key,),
              "Unicode range %r claimed not to be present, but at least "
              "one glyph from the range is in the font."))
    
    return r

# -----------------------------------------------------------------------------

#
# Exceptions
#

if 0:
    def __________________(): pass

class NoCmap(ValueError): pass
class NoEditor(ValueError): pass

# -----------------------------------------------------------------------------

#
# Classes
#

if 0:
    def __________________(): pass

class UnicodeRanges(object, metaclass=maskmeta.FontDataMetaclass):
    """
    """
    
    #
    # Class definition variables
    #
    
    maskByteLength = 16  # I do love Python! 128-bit integers are no problem.

    def msLongwordSwap128(n, **kwArgs):
        # Converts from this:
        # 31 ... 0 63 ... 32 64 ... 95 96 ... 127
        # to this:
        # 127 ... 0
        i1to4 = (n &  0xFFFFFFFF) << 96
        i2to3 = (n & (0xFFFFFFFF << 32)) << 32
        i3to2 = (n & (0xFFFFFFFF << 64)) >> 32
        i4to1 = (n & (0xFFFFFFFF << 96)) >> 96
        
        return i1to4 + i2to3 + i3to2 + i4to1

    maskControls = dict(
        loggername = "unicoderanges",
        validatecode_notsettozero = "E2117",
        validatefunc_partial = _validate,
        inputconvolutionfunc = msLongwordSwap128,
        outputconvolutionfunc = msLongwordSwap128)
    
    maskSorted = (
      'hasBasicLatin', 'hasLatin1Supplement', 'hasLatinExtendedA',
      'hasLatinExtendedB', 'hasIPA', 'hasModifierLetters',
      'hasCombiningDiacriticalMarks', 'hasBasicGreek',
      'hasGreekSymbolsAndCoptic', 'hasCyrillic', 'hasArmenian',
      'hasBasicHebrew', 'hasHebrewExtended', 'hasBasicArabic',
      'hasArabicExtended', 'hasDevanagari', 'hasBengali', 'hasGurmukhi',
      'hasGujarati', 'hasOriya', 'hasTamil', 'hasTelugu', 'hasKannada',
      'hasMalayalam', 'hasThai', 'hasLao', 'hasBasicGeorgian',
      'hasGeorgianExtended', 'hasHangulJamo', 'hasLatinExtendedAdditional',
      'hasGreekExtended', 'hasPunctuation', 'hasSuperscriptsAndSubscripts',
      'hasCurrency', 'hasSymbolCombiningDiacritics', 'hasLetterlike',
      'hasNumberForms', 'hasArrows', 'hasMathematical',
      'hasMiscellaneousTechnical', 'hasControlPictures', 'hasOCR',
      'hasEnclosed', 'hasBoxDrawing', 'hasBlockElements', 'hasGeometricShapes',
      'hasMiscellaneousSymbols', 'hasDingbats', 'hasCJKPunctuation',
      'hasHiragana', 'hasKatakana', 'hasBopomofo',
      'hasHangulCompatibilityJamo', 'hasCJKMiscellaneous', 'hasCJKEnclosed',
      'hasCJKCompatibility', 'hasHangulSyllables', 'hasCJKIdeographs',
      'hasPlaneZeroPrivate', 'hasCJKStrokes', 'hasAlphabeticPresentationForms',
      'hasArabicPresentationFormsA', 'hasCombiningHalfMarks',
      'hasVerticalForms', 'hasSmallFormVariants',
      'hasArabicPresentationFormsB', 'hasHalfAndFullWidthForms', 'hasSpecials')
    
    rangeIDToName = dict(zip(sorted(_rangeData), maskSorted))
    maskSpec = {}
    
    def makeClosure(rangeID):
        def f(old, **kwArgs):
            return _recalc(rangeID, old, **kwArgs)
        
        return f
    
    for rangeID, key in rangeIDToName.items():
        maskSpec[key] = dict(
          mask_isbool = True,
          mask_recalculatefunc = makeClosure(rangeID),
          mask_rightmostbitindex = rangeID,
          mask_showonlyiftrue = True)
    
    del key, rangeID, makeClosure

# -----------------------------------------------------------------------------

#
# Test code
#

if 0:
    def __________________(): pass

def _test():
    import doctest
    doctest.testmod()

if __name__ == "__main__":
    if __debug__:
        _test()
