#
# collection.py
#
# Copyright Â© 2007-2012 Monotype Imaging Inc. All Rights Reserved.
#

"""
Objects representing spans of integer values similar to those generated by
the range function.
"""

# System imports
import copy
import itertools

# Other imports (see also deferred imports, below)
from fontio3.fontmath import rational
from fontio3.utilities import MergeSyncFailure
from functools import reduce

# -----------------------------------------------------------------------------

#
# Private functions
#

def _keyCovers(k1, k2):
    """
    Returns True if all entries of k2 are covered by k1.
    
    ### _keyCovers((5, 2), (25, 2))
    True
    ### _keyCovers((6, 0), (4, 0))
    False
    """
    
    k1Skip, k1Phase = k1
    k2Skip, k2Phase = k2
    return (k2Skip % k1Skip == 0) and ((k2Phase - k1Phase) % k1Skip == 0)

# -----------------------------------------------------------------------------

#
# Public functions
#

if 0:
    def __________________(): pass

def cluster(n1, n2, coerceToNumber=True):
    """
    Take two objects which might be numbers or Collections and combine them
    into a single Collection. If coerceToNumber is True and the resulting
    Collection has only a single value, return that value; else return the
    Collection.
    
    ### cluster(1, 2)
    Singles: [1, 2]
    ### cluster(Collection([T(1, 11, 2)]), 4)
    Singles: [4], Ranges: [(1, 11, 2)]
    ### cluster(4, Collection([T(4, 4, 3)]))
    4
    ### cluster(4, Collection([T(4, 4, 3)]), coerceToNumber=False)
    Singles: [4]
    """
    
    if n1 == n2:
        return n1
    
    r = Collection()
    r = r.addToCollection(n1)
    r = r.addToCollection(n2)
    
    if coerceToNumber:
        if (None in r) or (len(r) != 1):
            pass
        else:
            r = r.toNumber(raiseException=False)
    
    return r

def combineDicts(d1, d2):
    """
    Combines the contents of d2 into d1.
    
    ### d1 = dict(itertools.izip(xrange(20), xrange(20)))
    ### d2 = {4: 25, 8: Collection([T(2, 8, 2)]), 26: -4}
    ### combineDicts(d1, d2)
    ### d1[4]
    Singles: [4, 25]
    ### d1[8]
    Ranges: [(2, 10, 2)]
    ### d1[26]
    -4
    """
    
    for k, n in d2.items():
        if k in d1:
            d1[k] = cluster(d1[k], n)
        else:
            d1[k] = n

def combineLists(v1, v2):
    """
    Combines v2 into v1.
    
    ### v1 = range(1, 5)
    ### v2 = [1, 3, 3, Collection([T(5, 9, 1)])]
    ### combineLists(v1, v2)
    ### v1
    [1, Singles: [2, 3], 3, Ranges: [(4, 9, 1)]]
    ### combineLists([], [4, 5])
    Traceback (most recent call last):
      ...
    MergeSyncFailure: Lists passed to combineLists cannot differ in length!
    """
    
    if len(v1) != len(v2):
        raise MergeSyncFailure("Lists passed to combineLists cannot differ in length!")
    
    for i, (n1, n2) in enumerate(zip(v1, v2)):
        if n1 != n2:
            v1[i] = cluster(n1, n2)

def mergeDicts(d1, d2):
    """
    Given two dicts whose values are numbers or Collections, returns a new dict
    with the union contents. If a given key is present in both d1 and d2, that
    entry in the merged output will be a Collection of the two values.
    
    ### d1 = dict(itertools.izip(xrange(20), xrange(20)))
    ### d2 = {4: 25, 8: Collection([T(2, 8, 2)])}
    ### d = mergeDicts(d1, d2)
    ### d[2]
    2
    ### d[4]
    Singles: [4, 25]
    ### d[8]
    Ranges: [(2, 10, 2)]
    """
    
    r = d1.copy()
    combineDicts(r, d2)
    return r

def mergeLists(v1, v2):
    """
    Given two lists whose values are numbers or Collections, returns a new list
    with the contents merged. Single differing entries at the same index are
    gathered into a Collection in the new list.

    An IndexError is raised if the lengths of the two lists differ.
    
    ### mergeLists([1, 2, 3, 4], [1, 3, 3, Collection([T(5, 9, 1)])])
    [1, Singles: [2, 3], 3, Ranges: [(4, 9, 1)]]
    ### mergeLists([1, 2, 3], [4, 5])
    Traceback (most recent call last):
      ...
    MergeSyncFailure: Lists passed to mergeLists cannot differ in length!
    """
    
    if len(v1) != len(v2):
        raise MergeSyncFailure("Lists passed to mergeLists cannot differ in length!")
    
    return [cluster(x, v2[i]) for i, x in enumerate(v1)]

def toCollection(x, newBasis=None):
    """
    Returns x if it is already a Collection, otherwise creates a new Collection
    whose contents match x and returns that.
    
    x may also be a float or a sequence of ints and/or floats.
    
    ### toCollection(5)
    Singles: [5]
    ### toCollection(T(4, 10, 2))
    Ranges: [(4, 10, 2)]
    ### tc = Collection([T(5, None, 41)])
    ### tc2 = toCollection(tc)
    ### tc is tc2
    True
    ### toCollection([3, 4.5, 6])
    Ranges: [(3.0, 7.5, 1.5)]
    ### toCollection([1.2, 1.4, 1.6], 64)
    Singles: [1.203125, 1.40625, 1.59375]
    """
    
    if isinstance(x, Collection):
        return x
    
    numBasis = (1 if newBasis is None else newBasis)
    
    if isinstance(x, T):
        return Collection([x], basis = numBasis)
    
    try:
        v = [obj for obj in x]
        
        if len(v) == 0:
            return Collection()
        
        if newBasis is None:
            vRat = [rational.floatToRational(n) for n in v]
            commonLCM = reduce(rational.lcm, [n.den for n in vRat])
            g = (n.num * (commonLCM // n.den) for n in vRat)
            g = utilities.tripleIteratorFromIterable(g)
            return Collection(g, commonLCM)
        
        g = utilities.tripleIteratorFromIterable((int(round(numBasis * n)) for n in v))
        return Collection(g, numBasis)
    
    except TypeError:
        if isinstance(x, float):
            if newBasis is None:
                n = rational.floatToRational(x)
                return Collection([T(n.num, n.num + 1, 1)], n.den)
            else:
                n = int(x * newBasis)
                return Collection([T(n, n + 1, 1)], newBasis)
        
        else:
            return Collection([T(x, x + 1, 1)], numBasis)

# -----------------------------------------------------------------------------

#
# Classes
#

if 0:
    def __________________(): pass

class Collection(object):
    """
    Objects which incrementally accumulate Triples, removing some (but not all)
    redundancies along the way.
    
    Collections are mutable, and thus not appropriate for being keys.
    """
    
    #
    # Initialization method
    #
    
    def __init__(self, iterable=None, basis=1):
        """
        Initializes the object with the specified Triples (if any).
        
        ### Collection([T(1, 11, 2), T(2, 12, 2)])
        Ranges: [(2, 12, 2), (1, 11, 2)]
        ### c = Collection([T(1, 11, 2), T(3, 30, 9)])
        ### c
        Singles: [12, 21], Ranges: [(1, 11, 2)]
        ### len(set(c)) == len(c)
        True
        """
        
        self.basis = basis
        self.d = {}
        self._cachedLen = 0
        self._openKeys = set()
        
        if iterable is not None:
            for t in iterable:
                self.addTriple(t)
    
    #
    # Special methods
    #
    
    def __abs__(self):
        """
        Returns a new Collection with the absolute value of self.
        
        ### tc = Collection([T(None, -8, 5), T(-26, 26, 4)])
        ### abs(tc)
        Singles: [13], Ranges: [(2, 30, 4), (23, *, 5)]
        """
        
        return Collection(self._genericUnary(T.abs))
    
    def __add__(self, other):
        """
        Returns a new Collection with the sum of self and other. Note that
        other may be another Collection, a Triple, or a simple integer.
        
        ### tc = Collection([T(1, 11, 2)])
        ### tc + 7
        Ranges: [(8, 18, 2)]
        ### tc + T(5, 11, 3)
        Ranges: [(6, 16, 2), (9, 19, 2)]
        ### tc + tc
        Ranges: [(2, 20, 2)]
        """
        
        self, other = self.commonBasis(toCollection(other))
        return Collection(self._genericBinary(other, T.add), self.basis)
    
    def __and__(self, other):
        """
        Returns a new Collection with the bitwise logical-AND of self and
        other. Note that other may be another Collection, a Triple, or a simple
        integer.
        
        ### tc = Collection([T(1, 11, 2)])
        ### tc & 7
        Ranges: [(1, 9, 2)]
        ### tc & T(5, 11, 3)
        Singles: [0, 1, 5, 8]
        ### tc & tc
        Ranges: [(1, 11, 2)]
        """
        
        self, other = self.commonBasis(toCollection(other))
        return Collection(self._genericBinary(other, T.and_), self.basis)
    
#     def __cmp__(self, other):
#         """
#         Raises NotImplementedError, because generic Collections have no sense
#         of ordering, just equality or inequality.
#         """
#         
#         raise NotImplementedError("Cannot order Collections!")
    
    def __contains__(self, n):
        """
        Returns True if the specified value n is in at least one Triple in the
        collection.
        
        ### 6 in Collection([T(1, 11, 2), T(6, 15, 3)])
        True
        ### 8 in Collection([T(1, 11, 2), T(6, 15, 3)])
        False
        ### 0.75 in Collection([T(1, 11, 2)], 4)
        True
        ### None in Collection([T(1, 11, 2)], 4)
        False
        ### None in Collection([T(1, None, 2)], 4)
        True
        """
        
        if n is None:
            return self._cachedLen is None
        
        if self.basis > 1:
            n = round(float(n) * self.basis)  # should this be rounded?
        
        n = int(n)
        return any(n in t for t in self.tripleIterator())
    
    def __deepcopy__(self, memo=None):
        """
        Returns a deep copy of the Collection.
        
        ### c1 = Collection([T(1, 11, 2), T(-50, None, 7), T(40, 50, 1)])
        ### c2 = c1.__deepcopy__()
        ### c1 is c2, c1 == c2
        (False, True)
        """
        
        if memo is None:
            memo = {}
        
        def _it():
            for t in self.tripleIterator():
                yield memo.setdefault(id(t), t.__deepcopy__(memo))
        
        return type(self)(_it(), basis=self.basis)
    
    def __div__(self, other):
        """
        Returns a new Collection with the (integer) quotient of self divided by
        other. Note that other may be another Collection, a Triple, or a simple
        integer.
        
        ### tc = Collection([T(40, 65, 5)])
        ### tc / 7
        Ranges: [(5, 9, 1)]
        ### tc / T(5, 11, 3)
        Ranges: [(5, 13, 1)]
        ### tc / tc
        Singles: [0, 1]
        ### Collection([T(15, 35, 5)], 4) / 3
        Singles: [1.25], Ranges: [(1.5, 3.0, 0.5)]
        """
        
        self, other = self.commonBasis(toCollection(other))
        b = self.basis
        
        if b == 1:
            return Collection(self._genericBinary(other, T.div))
        
        def f(t1, t2):
            start = (None if t1.start is None else t1.start * b)
            stop = (None if t1.stop is None else t1.stop * b)
            skip = t1.skip * b
            phase = t1.phase * b
            tNew = T(start, stop, skip, phase)
            
            for tResult in tNew.div(t2):
                yield tResult
        
        return Collection(self._genericBinary(other, f), self.basis)
    
    def __eq__(self, other):
        """
        Compares two Collections for equality.
        
        ### tc1 = Collection([T(1, 11, 2)])
        ### tc2 = Collection([T(1, 5, 2), T(5, 11, 2)])
        ### tc1 == tc2
        True
        ### tc1 == Collection()
        False
        ### Collection([T(1, 11, 2)], 4) == Collection([T(2, 22, 4)], 8)
        True
        ### Collection([T(1, 11, 2)]) == T(1, 11, 2)
        True
        ### Collection([T(4, 5, 1)], 2) == 2
        True
        """
        
        if self is other:
            return True
        
        try:
            if self.basis == other.basis and self.d == other.d:
                return True
        except AttributeError:
            pass
        
        self, other = self.commonBasis(toCollection(other))
        singlesSelf, singlesOther = set(), set()
        sd, od = {}, {}
        
        # The following filtering process is needed because single-length
        # Triples do not have unique representation. For instance, we can see
        # that T(4, 5, 1) equals T(4, 6, 2), even though their skips and phases
        # are different. We handle this by collecting all singles into sets and
        # comparing them separately.
        
        for src, d, s in ((self, sd, singlesSelf), (other, od, singlesOther)):
            for v in src.d.values():
                for t in v:
                    if None in t or len(t) > 1:
                        key = (t.skip, t.phase)
                        d.setdefault(key, []).append(t)
                    elif len(t) == 1:
                        s.add(t.start)
        
        if singlesSelf != singlesOther:
            return False
        
        if set(sd) != set(od):
            return False
        
        if any(sd[key] != od[key] for key in sd):
            return False
        
        return True
    
    def __float__(self):
        """
        Returns the floating-point value of the Collection if the length of the
        Collection is exactly 1; otherwise raises a ValueError.
        
        ### float(Collection([T(6, 16, 10)]))
        6.0
        ### float(Collection([T(6, 16, 10)], 8))
        0.75
        ### float(Collection([T(None, 4, 11)]))
        Traceback (most recent call last):
          ...
        ValueError: Cannot convert an open-ended Collection to an float!
        ### float(Collection([T(1, 11, 2)]))
        Traceback (most recent call last):
          ...
        ValueError: Cannot convert a Collection with multiple values to an float!
        """
        
        if self._cachedLen is None:
            raise ValueError("Cannot convert an open-ended Collection to an float!")
        
        if self._cachedLen != 1:
            raise ValueError("Cannot convert a Collection with multiple values to an float!")
        
        return float(next(iter(self)))
    
    __floordiv__ = __div__
    
    def __hash__(self): raise TypeError("Collections are unhashable!")
    
    def __iadd__(self, other):
        """
        Adds other to self in-place.
        
        ### tc = Collection([T(1, 11, 2)])
        ### savedIDs = (id(tc), id(tc.d))
        ### tc += 7
        ### tc
        Ranges: [(8, 18, 2)]
        ### savedIDs == (id(tc), id(tc.d))
        True
        """
        
        result = self + other
        self.basis = result.basis
        self._cachedLen = result._cachedLen
        self.d.clear()
        self.d.update(result.d)
        return self
    
    def __iand__(self, other):
        """
        Bitwise logical-ANDs other to self in-place.
        
        ### tc = Collection([T(1, 11, 2)])
        ### savedIDs = (id(tc), id(tc.d))
        ### tc &= 7
        ### tc
        Ranges: [(1, 9, 2)]
        ### savedIDs == (id(tc), id(tc.d))
        True
        """
        
        result = self & other
        self.basis = result.basis
        self._cachedLen = result._cachedLen
        self.d.clear()
        self.d.update(result.d)
        return self
    
    def __idiv__(self, other):
        """
        Divides self by other in-place.
        
        ### tc = Collection([T(40, 65, 5)])
        ### savedIDs = (id(tc), id(tc.d))
        ### tc /= 7
        ### tc
        Ranges: [(5, 9, 1)]
        ### savedIDs == (id(tc), id(tc.d))
        True
        """
        
        result = self / other
        self.basis = result.basis
        self._cachedLen = result._cachedLen
        self.d.clear()
        self.d.update(result.d)
        return self
    
    __ifloordiv__ = __idiv__
    
    def __ilshift__(self, other):
        """
        Shifts self in-place left by the amount specified by other.
        
        ### tc = Collection([T(1, 7, 2)])
        ### savedIDs = (id(tc), id(tc.d))
        ### tc <<= 2
        ### tc
        Ranges: [(4, 28, 8)]
        ### savedIDs == (id(tc), id(tc.d))
        True
        """
        
        result = self << other
        self.basis = result.basis
        self._cachedLen = result._cachedLen
        self.d.clear()
        self.d.update(result.d)
        return self
    
    def __imod__(self, other):
        """
        Applies other as a modulus to self.
        
        ### tc = Collection([T(1, 11, 2)])
        ### savedIDs = (id(tc), id(tc.d))
        ### tc %= T(3, 23, 5)
        ### tc
        Singles: [0, 2], Ranges: [(1, 11, 2)]
        ### savedIDs == (id(tc), id(tc.d))
        True
        """
        
        result = self % other
        self.basis = result.basis
        self._cachedLen = result._cachedLen
        self.d.clear()
        self.d.update(result.d)
        return self
    
    def __imul__(self, other):
        """
        Multiplies self by other.
        
        ### tc = Collection([T(1, 7, 2)])
        ### savedIDs = (id(tc), id(tc.d))
        ### tc *= tc
        ### tc
        Singles: [9, 15, 25], Ranges: [(1, 7, 2)]
        ### savedIDs == (id(tc), id(tc.d))
        True
        """
        
        result = self * other
        self.basis = result.basis
        self._cachedLen = result._cachedLen
        self.d.clear()
        self.d.update(result.d)
        return self
    
    def __int__(self):
        """
        Returns the integer value of the Collection if the length of the
        Collection is exactly 1; otherwise raises a ValueError.
        
        ### int(Collection([T(6, 16, 10)]))
        6
        ### int(Collection([T(6, 16, 10)], 4))
        1
        ### int(Collection([T(None, 4, 11)]))
        Traceback (most recent call last):
          ...
        ValueError: Cannot convert an open-ended Collection to an int!
        ### int(Collection([T(1, 11, 2)]))
        Traceback (most recent call last):
          ...
        ValueError: Cannot convert a Collection with multiple values to an int!
        """
        
        if self._cachedLen is None:
            raise ValueError("Cannot convert an open-ended Collection to an int!")
        
        if self._cachedLen != 1:
            raise ValueError("Cannot convert a Collection with multiple values to an int!")
        
        return int(next(iter(self)))
    
    def __invert__(self):
        """
        Returns a new Collection with the bitwise inversion of self.
        
        ### tc = Collection([T(None, 12, 8), T(50, 60, 1)])
        ### ~tc
        Ranges: [(-60, -50, 1), (-5, *, 8)]
        """
        
        return Collection((~t for t in self.tripleIterator()), self.basis)
    
    def __ior__(self, other):
        """
        Bitwise logical-ORs other to self in-place.
        
        ### tc = Collection([T(1, 11, 2)])
        ### savedIDs = (id(tc), id(tc.d))
        ### tc |= 7
        ### tc
        Singles: [7, 15]
        ### savedIDs == (id(tc), id(tc.d))
        True
        """
        
        result = self | other
        self.basis = result.basis
        self._cachedLen = result._cachedLen
        self.d.clear()
        self.d.update(result.d)
        return self
    
    def __ipow__(self, other, modulo=None):
        """
        Raises self to the power other, in-place.
        
        ### tc = Collection([T(-1, 5, 2)])
        ### savedIDs = (id(tc), id(tc.d))
        ### tc **= tc
        ### tc
        Singles: [3, 27], Ranges: [(-1, 2, 1)]
        ### savedIDs == (id(tc), id(tc.d))
        True
        """
        
        if modulo is not None:
            raise ValueError("__ipow__ does not support modulus")
        
        result = self ** other
        self.basis = result.basis
        self._cachedLen = result._cachedLen
        self.d.clear()
        self.d.update(result.d)
        return self
    
    def __irshift__(self, other):
        """
        Shifts self in-place right by the amount specified by other.
        
        ### tc = Collection([T(10, 22, 3)])
        ### savedIDs = (id(tc), id(tc.d))
        ### tc >>= 2
        ### tc
        Ranges: [(2, 5, 1)]
        ### savedIDs == (id(tc), id(tc.d))
        True
        """
        
        result = self >> other
        self.basis = result.basis
        self._cachedLen = result._cachedLen
        self.d.clear()
        self.d.update(result.d)
        return self
    
    def __isub__(self, other):
        """
        Subtracts other from self in-place.
        
        ### tc = Collection([T(1, 11, 2)])
        ### savedIDs = (id(tc), id(tc.d))
        ### tc -= 7
        ### tc
        Ranges: [(-6, 4, 2)]
        ### savedIDs == (id(tc), id(tc.d))
        True
        """
        
        result = self - other
        self.basis = result.basis
        self._cachedLen = result._cachedLen
        self.d.clear()
        self.d.update(result.d)
        return self
    
    def __iter__(self):
        """
        Returns an iterator over all the values (sorted). If any member Triples
        are open-ended a ValueError is raised.
        
        ### list(Collection([T(1, 11, 2), T(6, 15, 3)]))
        [1, 3, 5, 6, 7, 9, 12]
        ### list(Collection([T(1, 11, 2)], 4))
        [0.25, 0.75, 1.25, 1.75, 2.25]
        ### next(iter(Collection([T(None, 5, 2)])))
        Traceback (most recent call last):
          ...
        ValueError: Open-ended Collections cannot be iterated!
        """
        
        if self._cachedLen is None:
            raise ValueError("Open-ended Collections cannot be iterated!")
        
        b = (1 if self.basis == 1 else float(self.basis))
        
        allValues = set(
          (n / b if b != 1 else n)
          for v in self.d.values()
          for t in v
          for n in range(t.start, t.stop, t.skip))
        
        return iter(sorted(allValues))
        
#         iters = [iter(t) for obj in self.d.itervalues() for t in obj]
#         vals = [(next(it), i) for i, it in enumerate(iters)]
#         b = float(self.basis)
#         
#         while vals:
#             minValue = min(vals)[0]
#             yield (minValue if b == 1.0 else minValue / b)
#             toDeletes = []
#             
#             for valIndex, (candValue, j) in enumerate(vals):
#                 if candValue == minValue:
#                     try:
#                         vals[valIndex] = (next(iters[j]), j)
#                     except StopIteration:
#                         toDeletes.append(valIndex)
#             
#             for i in reversed(toDeletes):
#                 del vals[i]
    
    __itruediv__ = __idiv__
    
    def __ixor__(self, other):
        """
        Bitwise logical-XORs other to self in-place.
        
        ### tc = Collection([T(1, 11, 2)])
        ### savedIDs = (id(tc), id(tc.d))
        ### tc ^= 6
        ### tc
        Singles: [15], Ranges: [(1, 9, 2)]
        ### savedIDs == (id(tc), id(tc.d))
        True
        """
        
        result = self ^ other
        self.basis = result.basis
        self._cachedLen = result._cachedLen
        self.d.clear()
        self.d.update(result.d)
        return self
    
    def __len__(self):
        """
        This method returns the number of unique entries contained in the
        collection. If one or more contained Triples is open on one or both
        ends, this method raises a ValueError.
        
        ### len(Collection([T(3, 8, 1), T(10, 30, 2)]))
        15
        ### len(Collection([T(1, 11, 2), T(1, 11, 1)]))
        10
        ### len(Collection([T(None, 5, 3)]))
        Traceback (most recent call last):
          ...
        ValueError: Collection has infinite length!
        """
        
        if self._cachedLen is None:
            raise ValueError("Collection has infinite length!")
        
        return self._cachedLen
    
    def __lshift__(self, other):
        """
        Returns a new Collection whose values represent self left-shifted by
        other. Note that other may be another Collection, a Triple, or a simple
        integer.
        
        ### tc = Collection([T(1, 7, 2)])
        ### tc << 2
        Ranges: [(4, 28, 8)]
        ### tc << T(2, 4, 1)
        Ranges: [(4, 28, 8), (8, 56, 16)]
        ### tc << tc
        Ranges: [(2, 14, 4), (8, 56, 16), (32, 224, 64)]
        ### Collection([T(1, 11, 2)], 4) << 4
        Ranges: [(4.0, 44.0, 8.0)]
        """
        
        assert getattr(other, 'basis', 1) == 1, "Cannot have fractional shifts!"
        return Collection(self._genericBinary(other, T.lshift), self.basis)
    
    def __mod__(self, other):
        """
        Returns a new Collection whose values represent self modulus other.
        Note that other may be another Collection, a Triple, or a simple
        integer.
        
        ### tc = Collection([T(1, 11, 2)])
        ### tc % 7
        Singles: [5], Ranges: [(0, 4, 1)]
        ### tc % T(3, 23, 5)
        Singles: [0, 2], Ranges: [(1, 11, 2)]
        ### tc % tc
        Singles: [7], Ranges: [(0, 6, 1)]
        ### Collection([T(1, 11, 2)], 4) % 2
        Ranges: [(0.25, 2.25, 0.5)]
        """
        
        self, other = self.commonBasis(toCollection(other))
        return Collection(self._genericBinary(other, T.mod), self.basis)
    
    def __mul__(self, other):
        """
        Returns a new Collection whose values represent self times other.
        Note that other may be another Collection, a Triple, or a simple
        integer.
        
        ### tc = Collection([T(1, 7, 2)])
        ### tc * 7
        Ranges: [(7, 49, 14)]
        ### tc * T(-10, -4, 3)
        Ranges: [(-35, 7, 14), (-50, 10, 20)]
        ### tc * tc
        Singles: [9, 15, 25], Ranges: [(1, 7, 2)]
        ### Collection([T(28, 29, 1)], 4) * Collection([T(1, 2, 1)], 8)
        Singles: [0.75]
        """
        
        origSelfBasis = self.basis
        self, other = self.commonBasis(toCollection(other))
        scaleFactor = (self.basis * self.basis) // origSelfBasis
        
        if scaleFactor == 1:
            return Collection(self._genericBinary(other, T.mul))
        
        def f(t1, t2):
            for t in t1.mul(t2):
                for tScale in t.div(scaleFactor):
                    yield tScale
        
        return Collection(self._genericBinary(other, f), origSelfBasis)
    
    def __ne__(self, other): return not (self == other)
    
    def __neg__(self):
        """
        Returns a new Collection with the negation of self.
        
        ### tc = Collection([T(None, 12, 8), T(50, 60, 1)])
        ### -tc
        Ranges: [(-59, -49, 1), (-4, *, 8)]
        ### -Collection([T(1, 11, 2)], 4)
        Ranges: [(-2.25, 0.25, 0.5)]
        """
        
        return Collection((-t for t in self.tripleIterator()), self.basis)

    def __bool__(self):
        """
        Returns True if there is content present in the Collection.
        
        ### bool(Collection([T(1, 11, 2)]))
        True
        ### bool(Collection([T(1, 1, 1)]))
        False
        ### bool(Collection([T(None, 12, 1)]))
        True
        """
        
        return self._cachedLen != 0
    
    def __or__(self, other):
        """
        Returns a new Collection with the bitwise logical-OR of self and other.
        Note that other may be another Collection, a Triple, or a simple
        integer.
        
        ### tc = Collection([T(1, 11, 2)])
        ### tc | 7
        Singles: [7, 15]
        ### tc | T(5, 11, 3)
        Ranges: [(5, 17, 2)]
        ### tc | tc
        Ranges: [(1, 17, 2)]
        """
        
        self, other = self.commonBasis(toCollection(other))
        return Collection(self._genericBinary(other, T.or_), self.basis)
    
    def __pos__(self): return copy.deepcopy(self)
    
    def __pow__(self, other, modulo=None):
        """
        Returns a new Collection with self raised to the power other. Note that
        other may be another Collection, a Triple, or a simple integer.
        
        ### tc = Collection([T(-1, 5, 2)])
        ### tc ** 2
        Singles: [1, 9]
        ### tc ** T(-4, -1, 1)
        Ranges: [(-1, 2, 1)]
        ### tc ** tc
        Singles: [3, 27], Ranges: [(-1, 2, 1)]
        ### Collection([T(3, 9, 2)], 4) ** 3
        Singles: [0.25, 1.75, 5.25]
        """
        
        if modulo is not None:
            raise ValueError("__ipow__ does not support modulus")
        
        other = toCollection(other)
        assert other.basis == 1, "Cannot have fractional powers!"
        
        if other._cachedLen is None:
            return Collection(self._genericBinary(other, T.pow_), self.basis)
        
        def f(t1, t2):
            for k in t2:
                scale = self.basis ** (k - 1)
                
                for tResult in t1.pow_(k):
                    for tScale in tResult.div(scale):
                        yield tScale
        
        return Collection(self._genericBinary(other, f), self.basis)
    
    def __radd__(self, other):
        """
        Called when a Collection is on the right-hand side of an addition.
        
        ### tc = Collection([T(1, 11, 2)])
        ### 4 + tc
        Ranges: [(5, 15, 2)]
        ### T(3, 19, 4) + tc
        Ranges: [(4, 26, 2)]
        """
        
        return self + other
    
    def __rand__(self, other):
        """
        Called when a Collection is on the right-hand side of a logical-AND.
        
        ### tc = Collection([T(1, 11, 2)])
        ### 4 & tc
        Singles: [0, 4]
        ### T(5, 20, 5) & tc
        Singles: [5], Ranges: [(0, 4, 1), (7, 10, 1)]
        """
        
        return self & other
    
    def __rdiv__(self, other):
        """
        Called when a Collection is on the right-hand side of a logical-AND.
        
        ### tc = Collection([T(1, 11, 2)])
        ### 16 / tc
        Singles: [5, 16], Ranges: [(1, 4, 1)]
        """
        
        return toCollection(other) / self
    
    def __repr__(self):
        """
        Returns a representation string for the Collection.
        
        ### Collection([T(3, None, 6)])
        Ranges: [(3, *, 6)]
        ### Collection([T(None, None, 4, 3)])
        Ranges: [(*, *, 4, phase=3)]
        ### Collection([T(1, 11, 2), T(50, None, 1)], basis=4)
        Ranges: [(12.5, *, 0.25), (0.25, 2.75, 0.5)]
        ### Collection()
        Empty Collection
        """
        
        if self._cachedLen == 0:
            return "Empty Collection"
        
        singles = set()
        ranges = []
        sv = []
        b = float(self.basis)
        
        for t in self.tripleIterator():
            if None in t or len(t) > 2:
                ranges.append(t)
            else:
                singles.update(t)
        
        if singles:
            if b == 1.0:
                sv.append("Singles: %s" % (sorted(singles),))
            else:
                v = [n / b for n in sorted(singles)]
                sv.append("Singles: %s" % (v,))
        
        if ranges:
            if b == 1.0:
                sv.append("Ranges: [%s]" % (', '.join([repr(t) for t in ranges]),))
            else:
                svSub = []
                
                for t in ranges:
                    skip = t.skip / b
                    
                    if t.start is None and t.stop is None:
                        svSub.append('(*, *, %s, phase=%s)' % (skip, t.phase / b))
                    else:
                        start = ('*' if t.start is None else t.start / b)
                        stop = ('*' if t.stop is None else t.stop / b)
                        svSub.append('(%s, %s, %s)' % (start, stop, skip))
                
                sv.append("Ranges: [%s]" % (', '.join(svSub),))
        
        return ', '.join(sv)
    
    def __rlshift__(self, other):
        """
        Called when a Collection is on the right-hand side of a left-shift.
        
        ### tc = Collection([T(1, 3, 1)])
        ### 4 << tc
        Singles: [8, 16]
        """
        
        return toCollection(other) << self
    
    def __rmod__(self, other):
        """
        Called when a Collection is on the right-hand side of a modulus.
        
        ### tc = Collection([T(1, 11, 2)])
        ### 16 % tc
        Singles: [7], Ranges: [(0, 3, 1)]
        """
        
        return toCollection(other) % self
    
    def __rmul__(self, other):
        """
        Called when a Collection is on the right-hand side of a multiplication.
        
        ### tc = Collection([T(1, 11, 2)])
        ### 6 * tc
        Ranges: [(6, 66, 12)]
        """
        
        return self * other
    
    def __ror__(self, other):
        """
        Called when a Collection is on the right-hand side of a logical-OR.
        
        ### tc = Collection([T(1, 11, 2)])
        ### 6 | tc
        Singles: [7, 15]
        """
        
        return self | other
    
    def __rrshift__(self, other):
        """
        Called when a Collection is on the right-hand side of a right-shift.
        
        ### tc = Collection([T(1, 3, 1)])
        ### 8 >> tc
        Singles: [2, 4]
        """
        
        return toCollection(other) >> self
    
    def __rshift__(self, other):
        """
        Returns a new Collection whose values represent self right-shifted by
        other. Note that other may be another Collection, a Triple, or a simple
        integer.
        
        ### tc = Collection([T(10, 22, 3)])
        ### tc >> 2
        Ranges: [(2, 5, 1)]
        ### tc >> T(2, 4, 1)
        Ranges: [(1, 5, 1)]
        ### tc >> tc
        Singles: [0]
        """
        
        assert getattr(other, 'basis', 1) == 1, "Cannot have fractional shifts!"
        return Collection(self._genericBinary(other, T.rshift), self.basis)
    
    def __rsub__(self, other):
        """
        Called when a Collection is on the right-hand side of a subtraction.
        
        ### tc = Collection([T(1, 11, 2)])
        ### 1 - tc
        Ranges: [(-8, 2, 2)]
        """
        
        return (-self) + other
    
    def __rxor__(self, other):
        """
        Called when a Collection is on the right-hand side of a logical-XOR.
        
        ### tc = Collection([T(1, 11, 2)])
        ### 6 ^ tc
        Singles: [15], Ranges: [(1, 9, 2)]
        """
        
        return self ^ other
    
    def __sub__(self, other):
        """
        Returns a new Collection with the difference of self minus other. Note
        that other may be another Collection, a Triple, or a simple integer.
        
        ### tc = Collection([T(1, 11, 2)])
        ### tc - 7
        Ranges: [(-6, 4, 2)]
        ### tc - T(5, 11, 3)
        Ranges: [(-4, 6, 2), (-7, 3, 2)]
        ### tc - tc
        Ranges: [(-8, 10, 2)]
        ### Collection([T(1, 11, 2)], 4) - 10
        Ranges: [(-9.75, -7.25, 0.5)]
        """
        
        self, other = self.commonBasis(toCollection(other))
        return Collection(self._genericBinary(other, T.sub), self.basis)
    
    __truediv__ = __div__
    
    def __xor__(self, other):
        """
        Returns a new Collection with the difference of self minus other. Note
        that other may be another Collection, a Triple, or a simple integer.
        
        ### tc = Collection([T(1, 11, 2)])
        ### tc ^ 6
        Singles: [15], Ranges: [(1, 9, 2)]
        ### tc ^ T(5, 11, 3)
        Singles: [1, 2, 4], Ranges: [(9, 17, 2), (0, 18, 6)]
        ### tc ^ tc
        Ranges: [(0, 16, 2)]
        """
        
        self, other = self.commonBasis(toCollection(other))
        return Collection(self._genericBinary(other, T.xor), self.basis)
    
    #
    # Private methods
    #
    
    if 0:
        def _______________(): pass
    
    def _addFilteredPieces(self, toAdd):
        # update the cumulative length
        if self._cachedLen is None or any(None in t for t in toAdd):
            self._cachedLen = None
        else:
            self._cachedLen += sum(len(t) for t in toAdd)
        
        # add the new entries (remember, (None, None...) is gone)
        touchedKeys = set()
        
        for t in toAdd:
            key = (t.skip, t.phase)
            
            if key not in self.d:
                self.d[key] = [t]  # don't bother adding to touchedKeys here
            else:
                touchedKeys.add(key)
                v = self.d[key]
                
                if t.start is None:
                    v.insert(0, t)
                elif t.stop is None:
                    v.append(t)
                else:
                    for i, tOld in enumerate(v):
                        if tOld.start is not None and t.start < tOld.start:
                            v.insert(i, t)
                            break
                    else:
                        v.append(t)
        
        self._fuseAdjacentEdges(touchedKeys)
    
    def _combineToLowerSkips(self):
        skips = set(k[0] for k in self._openKeys if k[0] > 1)
        
        while skips:
            trySkip = max(skips)
            
            for divisor in rational.allDivisors(trySkip):
                if divisor != 1:
                    keys = set(k for k in self._openKeys if k[0] == trySkip)
                    q = trySkip // divisor
                    
                    for phase in range(q):
                        subKeys = set(k for k in keys if k[1] % q == phase)
                        
                        if len(subKeys) == divisor:
                            # we have an elision
                            for k in subKeys:
                                del self.d[k]
                            
                            self.d[(q, phase)] = [T(None, None, q, phase)]
                            self._openKeys.add((q, phase))
                            self._openKeys -= subKeys
                            skips.add(q)  # might cause cascades later
            
            skips.discard(trySkip)
    
    def _filterIntersections(self, newTriple):
        toAdd = [newTriple]
        
        for v in self.d.values():
            for tOld in v:
                toAddRevised = []
                
                for tAdd in toAdd:
                    toAddRevised.extend(tAdd.difference(tOld))
                
                toAdd[:] = toAddRevised
            
            if len(toAdd) == 0:
                break
        
        return toAdd
    
    def _fuseAdjacentEdges(self, touchedKeys):
        for key in touchedKeys:
            if key in self.d:  # have to test, because might have been removed
                v = self.d[key]
                i = 0
                
                while i < len(v) - 1:
                    tThis, tNext = v[i:i+2]
                    
                    if tThis.stop >= tNext.start:
                        v[i] = T(tThis.start, tNext.stop, *key)
                        del v[i+1]
                    else:
                        i += 1
                
                if len(v) == 1 and v[0].start is None and v[0].stop is None:
                    self._removeKeysCoveredBy(key)
    
    def _gatherSingles(self):
        """
        Returns a pair. The first element of this pair is a dict, possibly
        empty, whose keys are values from member Triples whose lengths are 1 or
        2, and whose values are (listIndex, key) pairs. The second element of
        the pair is a count of the number of Triples which were subsumed into
        the dict.
        """
        
        d = {}
        count = 0
        
        for k, v in self.d.items():
            for i, t in enumerate(v):
                if t.start is not None and t.stop is not None:
                    theLen = len(t)
                    entry = (i, k)
                    
                    if theLen == 1:
                        d[t.start] = entry
                        count += 1
                    elif theLen == 2:
                        d[t.start] = entry
                        d[t.start + t.skip] = entry
                        count += 1
        
        return (d, count)
    
    def _genericBinary(self, other, func):
        """
        Returns an iterator over Triples representing the application of func
        to Triples from self and Triples from other. This means func must take
        two Triples and return an iterator over Triples.

        Note that other may be another Collection, a Triple, or a simple
        integer.
        
        ### tc = Collection([T(1, 11, 2)])
        ### list(tc._genericBinary(7, T.add))
        [(8, 18, 2)]
        """
        
        try:
            for t2 in other.tripleIterator():
                for t1 in self.tripleIterator():
                    for t in func(t1, t2):
                        yield t
        
        except AttributeError:
            for t1 in self.tripleIterator():
                for t in func(t1, other):
                    yield t
    
    def _genericUnary(self, func):
        """
        Returns an iterator over Triples representing the application of func
        to Triples from self. This means func must take a Triple and return an
        iterator over Triples.
        
        ### tc = Collection([T(None, -8, 5), T(-26, 26, 4)])
        ### Collection(tc._genericUnary(T.abs))
        Singles: [13], Ranges: [(2, 30, 4), (23, *, 5)]
        """
        
        for t1 in self.tripleIterator():
            for t in func(t1):
                yield t
    
    def _itemIterator(self):
        """
        Returns an iterator over Triples in self.d. The actual value returned
        by the iterator's next() method is a tuple (key, indexInList, triple).
        """
        
        for key in sorted(self.d):
            v = self.d[key]
            
            for i, t in enumerate(v):
                yield (key, i, t)
    
    def _isCoveredByOpenKey(self, newTriple):
        newKey = (newTriple.skip, newTriple.phase)
        return any(_keyCovers(k, newKey) for k in self._openKeys)
    
    def _removeKeysCoveredBy(self, openKey):
        toRemove = set(k for k in self.d if k != openKey and _keyCovers(openKey, k))
        self._openKeys -= toRemove
        self._openKeys.add(openKey)
        
        for k in toRemove:
            del self.d[k]
    
    def _removeTriplesCoveredBy(self, newTriple):
        for k in list(self.d):
            v = self.d[k]
            vNew = []
            
            for t in v:
                sect = t.intersection(newTriple)
                
                if sect is None or sect != t:
                    vNew.append(t)
                elif self._cachedLen is not None:
                    self._cachedLen -= len(t)
            
            if vNew:
                v[:] = vNew
            else:
                del self.d[k]
                self._openKeys.discard(k)  # no harm if not there
    
    def _scaleBasis(self, scale):
        """
        Returns either self (if scale is one), or a new Collection whose values
        equal the values in self but whose basis has been scaled.
        
        This method only scales up, so scale must be >= 1.
        
        ### tc = Collection([T(1, 11, 2)], basis=4)
        ### tc
        Ranges: [(0.25, 2.75, 0.5)]
        ### tc.basis
        4
        ### tc2 = tc._scaleBasis(16)
        ### tc2
        Ranges: [(0.25, 2.75, 0.5)]
        ### tc2.basis
        64
        """
        
        assert scale >= 1 and scale == int(scale), "Bad scale passed to _scaleBasis!"
        
        if scale == 1:
            return self
        
        g = itertools.chain(*[t.mul(scale) for t in self.tripleIterator()])
        return Collection(iterable=g, basis=self.basis * scale)
    
    def _tryToFuseSingles(self):
        dSingles = self._gatherSingles()[0]  # don't care about subsumedCount
        
        if dSingles:
            sSinglesKeys = set(dSingles.values())
            dEdges = {}
            toDelete = []
            touchedKeys = set()
            
            for k, v in self.d.items():
                for i, t in enumerate(v):
                    if (i, k) not in sSinglesKeys:
                        if t.start is not None:
                            n = t.start - t.skip
                            old = dEdges.get(n, None)
                            
                            if old is None or k[0] < old[0][0]:
                                dEdges[n] = ((k, i, 0))
                        
                        if t.stop is not None:
                            n = t.stop
                            old = dEdges.get(n, None)
                            
                            if old is None or k[0] < old[0][0]:
                                dEdges[n] = ((k, i, 1))
            
            for n in dSingles:
                if n in dEdges:
                    nIndex, nKey = dSingles[n]
                    rKey, rIndex, rEnd = dEdges[n]
                    tOld = self.d[rKey][rIndex]
                    tDbl = self.d[nKey][nIndex]
                    
                    if rEnd == 0:
                        self.d[rKey][rIndex] = T(n, tOld.stop, tOld.skip)
                        newKey = n - tOld.skip
                    else:
                        newKey = n + tOld.skip
                        self.d[rKey][rIndex] = T(tOld.start, newKey, tOld.skip)
                    
                    if len(tDbl) == 1:
                        toDelete.append((nIndex, nKey))
                    elif n == tDbl.start:
                        self.d[nKey][nIndex] = T(n + tDbl.skip, tDbl.stop, tDbl.skip)
                    else:
                        self.d[nKey][nIndex] = T(n, n + tDbl.skip, tDbl.skip)
                        
                    if newKey not in dEdges:
                        dEdges[newKey] = dEdges[n]
                        del dEdges[n]
                        
                    touchedKeys.add(rKey)
            
            for index, key in reversed(sorted(toDelete)):
                del self.d[key][index]
            
            self._fuseAdjacentEdges(touchedKeys)
    
    def _tryToMergeSingles(self):
        dSingles, subsumedCount = self._gatherSingles()
        
        if dSingles:
            vAttempt = utilities.tripleListFromIterable(dSingles)
            
            if len(vAttempt) < subsumedCount:
                # Rather than fussing with resolving potential movements (from a 2
                # to a 1, for instance), we just remove all the olds and add all
                # news.
                s = set(dSingles.values())
                keysToDelete = set()
                
                for i, k in reversed(sorted(s)):
                    v = self.d[k]
                    
                    if self._cachedLen is not None:
                        self._cachedLen -= len(v[i])
                    
                    del v[i]
                    
                    if len(v) == 0:
                        keysToDelete.add(k)
                
                for k in keysToDelete:
                    del self.d[k]
                
                self._addFilteredPieces(vAttempt)
    
    #
    # Public methods
    #
    
    if 0:
        def _______________(): pass
    
    def addToCollection(self, other):
        """
        Adds all the values from other into self. Note that other may be an
        integer, a Triple or a Collection (although if it's a Triple, you may
        prefer to call addTriple directly).
        
        IMPORTANT NOTE: Because of the possibility of basis changes, this
        method returns self. The caller should *always* reassign their binding
        using this returned result.
        
        ### tc = Collection([T(1, 11, 2)])
        ### tc
        Ranges: [(1, 11, 2)]
        ### tc.addToCollection(50)
        Singles: [50], Ranges: [(1, 11, 2)]
        ### tc.addToCollection([51, 52, 53])
        Ranges: [(50, 54, 1), (1, 11, 2)]
        ### tc.addToCollection(tc + 1)
        Ranges: [(50, 55, 1), (2, 12, 2), (1, 11, 2)]
        """
        
        self, other = self.commonBasis(toCollection(other))
        
        for t in other.tripleIterator():
            self.addTriple(t)
        
        return self  # it might have changed via the commonBasis call
    
    def addTriple(self, newTriple):
        """
        Adds the new triple to the collection and updates the cached length.
        
        ### tc = Collection()
        ### tc
        Empty Collection
        ### tc.addTriple(T(1, 11, 2))
        ### tc
        Ranges: [(1, 11, 2)]
        ### tc.addTriple(T(4, 14, 5))
        ### tc
        Singles: [4], Ranges: [(1, 11, 2)]
        ### len(tc)
        6
        ### tc.addTriple(T(0, 20, 1))
        ### tc
        Ranges: [(0, 20, 1)]
        ### len(tc)
        20
        ### tc.addTriple(T(10, None, 1))
        ### tc
        Ranges: [(0, *, 1)]
        """
        
        self._removeTriplesCoveredBy(newTriple)
        
        if not self._isCoveredByOpenKey(newTriple):
            if newTriple.start is None and newTriple.stop is None:
                newKey = (newTriple.skip, newTriple.phase)
                self.d[newKey] = [newTriple]
                self._cachedLen = None
                self._removeKeysCoveredBy(newKey)
            
            else:
                toAdd = self._filterIntersections(newTriple)
                
                if toAdd:
                    self._addFilteredPieces(toAdd)
        
        self._tryToMergeSingles()
        self._tryToFuseSingles()
        #self._combineToLowerSkips()
    
    def asImmutable(self, **kwArgs):
        """
        Returns a tuple of tuples representing all the Triples in the
        Collection, with the last element being the basis.
        
        ### Collection([T(1, 11, 2), T(-50, None, 7), T(40, 50, 1)]).asImmutable()
        ((40, 48, 2, 0), (1, 11, 2, 1), (43, 51, 2, 1), (-50, None, 7, 6), 1)
        """
        
        return tuple(obj.asImmutable() for obj in self.tripleIterator()) + (self.basis,)
    
    def asList(self):
        """
        Returns a simple list of Triples taken from all the values in the
        Collection.
        
        ### tc = Collection([T(1, 11, 2), T(-50, None, 7), T(40, 50, 1)])
        ### tc.asList()
        [(40, 48, 2), (1, 11, 2), (43, 51, 2), (-50, *, 7)]
        """
        
        return list(self.tripleIterator())
    
    def ceiling(self):
        """
        Returns a new Collection with the ceiling of self.
        
        ### Collection([T(1, 11, 2)]).ceiling()
        Ranges: [(1, 11, 2)]
        ### Collection([T(None, None, 11, 4)], 64).ceiling()
        Ranges: [(*, *, 1, phase=0)]
        ### Collection([T(None, None, 6, 1)], 4).ceiling()
        Ranges: [(*, *, 3, phase=1), (*, *, 3, phase=2)]
        ### Collection([T(None, 61, 6)], 32).ceiling()
        Ranges: [(*, 3, 1)]
        ### Collection([T(None, 61, 6)], 4).ceiling()
        Ranges: [(*, 16, 3), (*, 17, 3)]
        ### Collection([T(17, None, 3)], 4).ceiling()
        Ranges: [(5, *, 1)]
        ### Collection([T(7, None, 6)], 4).ceiling()
        Ranges: [(4, *, 3), (2, *, 3)]
        ### Collection([T(1, 11, 2)], 4).ceiling()
        Ranges: [(1, 4, 1)]
        ### Collection([T(5, 35, 5)], 4).ceiling()
        Singles: [7, 8], Ranges: [(2, 6, 1)]
        ### Collection([T(5, 20, 5)], 4).ceiling()
        Ranges: [(2, 5, 1)]
        """
        
        b = self.basis
        
        if b == 1:
            return copy.deepcopy(self)
        
        return (self.changedBasis(1) + (b - 1)).changedBasis(b).floor()
    
    def changedBasis(self, newBasis):
        """
        Returns a new Collection whose member integers are the same as in self,
        but whose basis is the new value. Note this changes the actual values!
        
        ### tc = Collection([T(1, 11, 2)], 4)
        ### tc
        Ranges: [(0.25, 2.75, 0.5)]
        ### tc.changedBasis(1)
        Ranges: [(1, 11, 2)]
        """
        
        retVal = copy.deepcopy(self)
        retVal.basis = newBasis
        return retVal
    
    def collectionMax(self, other):
        """
        Returns a Collection with the results of all possible max() calls with
        members of self and members of other.
        
        ### Collection([T(1, 11, 2)]).collectionMax(Collection([T(6, 60, 9)]))
        Singles: [7, 9], Ranges: [(6, 60, 9)]
        """
        
        self, other = self.commonBasis(other)
        f = lambda t1, t2: t1.tripleMax(t2)
        return Collection(self._genericBinary(other, f), self.basis)
    
    def collectionMin(self, other):
        """
        Returns a Collection with the results of all possible min() calls with
        members of self and members of other.
        
        ### Collection([T(1, 11, 2)]).collectionMin(Collection([T(6, 60, 9)]))
        Singles: [6], Ranges: [(1, 11, 2)]
        """
        
        self, other = self.commonBasis(other)
        f = lambda t1, t2: t1.tripleMin(t2)
        return Collection(self._genericBinary(other, f), self.basis)
    
    def commonBasis(self, other):
        """
        Returns a pair of Collections numerically equal to the input pair, but
        whose basis values are equal. If they started out equal, the original
        objects (not copies) are returned.
        
        ### tc1 = Collection([T(1, 11, 2)], basis=4)
        ### tc2 = Collection([T(-4, -1, 1)])
        ### (tc1, tc2)
        (Ranges: [(0.25, 2.75, 0.5)], Ranges: [(-4, -1, 1)])
        ### (tc1.basis, tc2.basis)
        (4, 1)
        ### tc3, tc4 = tc1.commonBasis(tc2)
        ### (tc3, tc4)
        (Ranges: [(0.25, 2.75, 0.5)], Ranges: [(-4.0, -1.0, 1.0)])
        ### (tc3.basis, tc4.basis)
        (4, 4)
        """
        
        if self.basis == other.basis:
            return (self, other)
        
        newBasis = rational.lcm(self.basis, other.basis)
        newSelf = self._scaleBasis(newBasis // self.basis)
        newOther = other._scaleBasis(newBasis // other.basis)
        return (newSelf, newOther)
    
    def convertToBasis(self, newBasis, round=True):
        """
        Returns a new Collection whose values are converted from the existing
        basis to the specified new basis. These values are either rounded or
        truncated, depending on the value of the round parameter.
        
        ### Collection([T(1, 9, 2)], 4).convertToBasis(16)
        Ranges: [(0.25, 2.25, 0.5)]
        ### Collection([T(1, 9, 2)], 16).convertToBasis(4)
        Ranges: [(0.0, 0.75, 0.25)]
        ### Collection([T(1, 9, 2)], 16).convertToBasis(4, False)
        Singles: [0.0, 0.25]
        """
        
        def f():
            for t in self.tripleIterator():
                for tResult in t.basisToBasis(self.basis, newBasis, round):
                    yield tResult
        
        return Collection(f(), newBasis)
    
    def encompassedBooleans(self):
        """
        Returns a Collection which will either be empty, or else will contain
        0, 1 or both 0 and 1, depending on the presence or absence if zero and
        nonzero values in self.
        
        ### Collection().encompassedBooleans()
        Empty Collection
        ### Collection([T(1, 11, 2)]).encompassedBooleans()
        Singles: [1]
        ### Collection([T(0, 4, 4), T(0, 13, 13)]).encompassedBooleans()
        Singles: [0]
        ### Collection([T(-10, 10, 2)]).encompassedBooleans()
        Singles: [0, 1]
        """
        
        lowValue = (0 if 0 in self else 1)
        hasNonzero = any(
          t.start is None or
          t.start != 0 or
          t.stop is None or
          (t.stop - t.skip) != 0
          for t in self.tripleIterator())
        highValue = (2 if hasNonzero else 1)
        return Collection([triple.Triple(lowValue, highValue, 1)])
    
    def equal(self, other):
        """
        Returns a new Collection with values 0, 1, or 0 and 1 indicating the
        equality of the two input Collections. Note this differs from the
        __eq__ special method, which tests for identical content and simply
        returns True or False.
        
        ### Collection([T(1, 3, 2)]).equal(1)
        Singles: [1]
        ### Collection([T(1, 11, 2)]).equal(Collection([T(1, 11, 2)]))
        Singles: [0, 1]
        ### Collection().equal(Collection())
        Singles: [1]
        ### Collection([T(1, 11, 2)]).equal(-4)
        Singles: [0]
        """
        
        self, other = self.commonBasis(toCollection(other))
        
        if self == other:
            if self._cachedLen is not None and self._cachedLen < 2:
                v = [1]
            else:
                v = [0, 1]
        else:
            sect = self.intersection(other)
            v = ([0] if sect._cachedLen == 0 else [0, 1])
        
        return toCollection(v)
    
    def floor(self):
        """
        Returns a new Collection with the mathematical floor of self. Note the
        returned Collection always has a basis of 1.
        
        ### Collection([T(1, 11, 2)]).floor()
        Ranges: [(1, 11, 2)]
        ### Collection([T(None, None, 11, 4)], 64).floor()
        Ranges: [(*, *, 1, phase=0)]
        ### Collection([T(None, None, 6, 1)], 4).floor()
        Ranges: [(*, *, 3, phase=0), (*, *, 3, phase=1)]
        ### Collection([T(None, 61, 6)], 32).floor()
        Ranges: [(*, 2, 1)]
        ### Collection([T(None, 61, 6)], 4).floor()
        Ranges: [(*, 15, 3), (*, 16, 3)]
        ### Collection([T(17, None, 3)], 4).floor()
        Ranges: [(4, *, 1)]
        ### Collection([T(7, None, 6)], 4).floor()
        Ranges: [(3, *, 3), (1, *, 3)]
        ### Collection([T(1, 11, 2)], 4).floor()
        Ranges: [(0, 3, 1)]
        ### Collection([T(5, 35, 5)], 4).floor()
        Ranges: [(1, 4, 1), (5, 8, 1)]
        ### Collection([T(5, 20, 5)], 4).floor()
        Ranges: [(1, 4, 1)]
        """
        
        b = self.basis
        
        if b == 1:
            return copy.deepcopy(self)
        
        def f(t):
            if t.start is None:
                if t.stop is None:
                    if t.skip <= b:
                        yield T(None, None, 1, 0)
                    
                    else:
                        gcf = rational.gcf(t.skip, b)
                        cycle = (t.skip * b) // gcf
                        newSkip = cycle // b
                        
                        for i in range(t.phase, t.phase + cycle, t.skip):
                            yield T(None, None, newSkip, (i - i % b) // b)
                
                else:
                    lastInt = t.stop - t.skip
                    
                    if t.skip <= b:
                        yield T(None, (lastInt // b) + 1, 1)
                    
                    else:
                        gcf = rational.gcf(t.skip, b)
                        cycle = (t.skip * b) // gcf
                        newSkip = cycle // b
                        
                        for i in range(lastInt, lastInt - cycle, -t.skip):
                            yield T(None, ((i - i % b) // b) + newSkip, newSkip)
            
            else:
                if t.stop is None:
                    if t.skip <= b:
                        yield T(t.start // b, None, 1)
                    
                    else:
                        gcf = rational.gcf(t.skip, b)
                        cycle = (t.skip * b) // gcf
                        newSkip = cycle // b
                        
                        for i in range(t.start, t.start + cycle, t.skip):
                            yield T((i - i % b) // b, None, newSkip)
                
                else:
                    lastInt = t.stop - t.skip
                    
                    if t.skip <= b:
                        yield T(t.start // b, (lastInt // b) + 1, 1)
                    
                    else:
                        gcf = rational.gcf(t.skip, b)
                        cycle = (t.skip * b) // gcf
                        newSkip = cycle // b
                        
                        for i in range(t.start, min(t.stop, t.start + cycle), t.skip):
                            startInt = i - i % b
                            thisLast = T(startInt, None, cycle).findMember(True, True, lastInt)
                            yield T(startInt // b, (thisLast // b) + newSkip, newSkip)
        
        return Collection(self._genericUnary(f))
    
    def greater(self, other):
        """
        Returns a Collection containing 0, 1, or 0 and 1, depending on whether
        self is strictly greater than other. Note this means you can interpret
        the return result as follows: a 1 means at least one element of self is
        strictly greater than at least one element of other, and a 0 means at
        least one element of self is less than or equal to at least one element
        of other.
        
        ### Collection().greater(Collection([T(1, 11, 2)]))
        Singles: [0]
        ### Collection([T(1, 11, 2)]).greater(Collection())
        Singles: [1]
        ### Collection([T(None, None, 3, 2)]).greater(Collection([T(1, 11, 2)]))
        Singles: [0, 1]
        ### Collection([T(None, 25, 4)]).greater(Collection([T(None, -50, 18)]))
        Singles: [0, 1]
        ### Collection([T(None, 25, 4)]).greater(Collection([T(20, 200, 9)]))
        Singles: [0, 1]
        ### Collection([T(None, 25, 4)]).greater(Collection([T(21, 201, 9)]))
        Singles: [0]
        ### Collection([T(1, None, 15)]).greater(Collection([T(-10, None, 3)]))
        Singles: [0, 1]
        ### Collection([T(1, 31, 15)]).greater(Collection([T(None, None, 3, 2)]))
        Singles: [0, 1]
        ### Collection([T(1, 11, 2)]).greater(Collection([T(8, None, 4)]))
        Singles: [0, 1]
        ### Collection([T(1, 11, 2)]).greater(Collection([T(9, None, 4)]))
        Singles: [0]
        ### Collection([T(86, None, 2)]).greater(Collection([T(10, 90, 5)]))
        Singles: [1]
        ### Collection([T(85, None, 2)]).greater(Collection([T(10, 90, 5)]))
        Singles: [0, 1]
        ### Collection([T(34, 134, 2)]).greater(Collection([T(None, 40, 7)]))
        Singles: [1]
        ### Collection([T(33, 133, 2)]).greater(Collection([T(None, 40, 7)]))
        Singles: [0, 1]
        ### Collection([T(35, 55, 5)]).greater(Collection([T(0, 51, 17)]))
        Singles: [1]
        ### Collection([T(1, 11, 2)]).greater(Collection([T(9, 99, 3)]))
        Singles: [0]
        ### Collection([T(1, 11, 2)]).greater(Collection([T(1, 11, 2)]))
        Singles: [0, 1]
        """
        
        if self._cachedLen == 0:
            v = [0]
        
        elif other._cachedLen == 0:
            v = [1]
        
        else:
            self, other = self.commonBasis(toCollection(other))
            a = self.min(convertToBasis=False)
            b = self.max(convertToBasis=False)
            c = other.min(convertToBasis=False)
            d = other.max(convertToBasis=False)
            
            if a is None or d is None:
                if b is None or c is None:
                    v = [0, 1]
                else:
                    v = ([0, 1] if b > c else [0])
            elif b is None or c is None:
                v = ([1] if a > d else [0, 1])
            elif a > d:
                v = [1]
            elif b <= c:
                v = [0]
            else:
                v = [0, 1]
        
        return toCollection(v)
    
    def intersection(self, other):
        """
        Returns a Collection containing only those elements in common in the
        two input objects.
        
        ### Collection([T(-50, 0, 5), T(1, 11, 2), T(20, 40, 5)]).intersection(T(5, None, 30))
        Singles: [5, 35]
        """
        
        self, other = self.commonBasis(toCollection(other))
        
        def f(t1, t2):
            sect = t1.intersection(t2)
            
            if sect is not None:
                yield sect
        
        return Collection(self._genericBinary(other, f), self.basis)
    
    def less(self, other):
        """
        Returns a Collection containing 0, 1, or 0 and 1, depending on whether
        self is strictly less than other. Note this means you can interpret the
        return result as follows: a 1 means at least one element of self is
        strictly less than at least one element of other, and a 0 means at
        least one element of self is greater than or equal to at least one
        element of other.
        
        ### Collection([T(1, 11, 2)]).less(Collection())
        Singles: [0]
        ### Collection().less(Collection([T(1, 11, 2)]))
        Singles: [1]
        ### Collection([T(None, None, 5, 3)]).less(Collection([T(1, 11, 2)]))
        Singles: [0, 1]
        ### Collection([T(None, 15, 5)]).less(Collection([T(None, 0, 10)]))
        Singles: [0, 1]
        ### Collection([T(None, 15, 5)]).less(Collection([T(11, 31, 2)]))
        Singles: [1]
        ### Collection([T(None, 15, 5)]).less(Collection([T(10, 30, 2)]))
        Singles: [0, 1]
        ### Collection([T(5, None, 4)]).less(Collection([T(19, None, 11)]))
        Singles: [0, 1]
        ### Collection([T(1, 11, 2)]).less(Collection([T(None, None, 18, 5)]))
        Singles: [0, 1]
        ### Collection([T(1, 11, 2)]).less(Collection([T(10, None, 1)]))
        Singles: [1]
        ### Collection([T(1, 11, 2)]).less(Collection([T(9, None, 1)]))
        Singles: [0, 1]
        ### Collection([T(10, None, 4)]).less(Collection([T(-15, 15, 3)]))
        Singles: [0, 1]
        ### Collection([T(12, None, 4)]).less(Collection([T(-15, 15, 3)]))
        Singles: [0]
        ### Collection([T(1, 11, 2)]).less(Collection([T(None, 7, 5)]))
        Singles: [0, 1]
        ### Collection([T(1, 11, 2)]).less(Collection([T(None, 6, 5)]))
        Singles: [0]
        ### Collection([T(1, 11, 2)]).less(Collection([T(-10, 2, 1)]))
        Singles: [0]
        ### Collection([T(1, 11, 2)]).less(Collection([T(10, 100, 5)]))
        Singles: [1]
        ### Collection([T(1, 11, 2)]).less(Collection([T(1, 11, 2)]))
        Singles: [0, 1]
        """
        
        if other._cachedLen == 0:
            v = [0]
        
        elif self._cachedLen == 0:
            v = [1]
        
        else:
            self, other = self.commonBasis(toCollection(other))
            a = self.min(convertToBasis=False)
            b = self.max(convertToBasis=False)
            c = other.min(convertToBasis=False)
            d = other.max(convertToBasis=False)
            
            if a is None or d is None:
                if b is None or c is None:
                    v = [0, 1]
                else:
                    v = ([1] if b < c else [0, 1])
            elif b is None or c is None:
                v = ([0, 1] if a < d else [0])
            elif a >= d:
                v = [0]
            elif b < c:
                v = [1]
            else:
                v = [0, 1]
        
        return toCollection(v)
    
    def logicalNOT(self):
        """
        Returns a new Collection (basis 1, irrespective of self.basis)
        containing the logical inverse of the results of the
        encompassedBooleans call.
        
        ### Collection([T(4, 14, 2)]).logicalNOT()
        Singles: [0]
        ### Collection([T(0, 1, 1)]).logicalNOT()
        Singles: [1]
        ### Collection([T(-4, 4, 2)]).logicalNOT()
        Singles: [0, 1]
        ### Collection().logicalNOT()
        Empty Collection
        """
        
        return toCollection(((1 - n) for n in self.encompassedBooleans()))
    
    def max(self, convertToBasis=True):
        """
        Returns the maximum value in the Collection, or None if the collection
        is either empty or open-ended on the right. The default case is to
        return the scaled value; however, if convertToBasis is False then the
        raw value is returned instead.
        
        ### Collection().max() is None
        True
        ### Collection([T(15, None, 2)]).max() is None
        True
        ### Collection([T(None, 19, 5)]).max()
        14
        ### Collection([T(1, 11, 2), T(30, 40, 5)]).max()
        35
        ### Collection([T(1, 11, 2)], 4).max()
        2.25
        ### Collection([T(1, 11, 2)], 4).max(False)
        9
        """
        
        currMax = None
        
        for v in self.d.values():
            t = v[-1]
            
            if t.stop is None:
                return None
            
            last = t.stop - t.skip
            currMax = (last if currMax is None else max(currMax, last))
        
        if (currMax is not None) and convertToBasis and self.basis != 1:
            currMax /= float(self.basis)
        
        return currMax
    
    def min(self, convertToBasis=True):
        """
        Returns the minimum value in the Collection, or None if the collection
        is either empty or open-ended on the left. The default case is to
        return the scaled value; however, if convertToBasis is False then the
        raw value is returned instead.
        
        ### Collection().min() is None
        True
        ### Collection([T(None, 15, 2)]).min() is None
        True
        ### Collection([T(19, None, 5)]).min()
        19
        ### Collection([T(1, 11, 2), T(-30, -20, 5)]).min()
        -30
        ### Collection([T(1, 11, 2)], 4).min()
        0.25
        ### Collection([T(1, 11, 2)], 4).min(False)
        1
        """
        
        currMin = None
        
        for v in self.d.values():
            t = v[0]
            
            if t.start is None:
                return None
            
            currMin = (t.start if currMin is None else min(currMin, t.start))
        
        if (currMin is not None) and convertToBasis and self.basis != 1:
            currMin /= float(self.basis)
        
        return currMin
    
    def round(self, powerOfTwo=0):
        """
        Returns a new Collection representing self rounded to the nearest unit in
        units of the powerOfTwo. Thus, 1.3 rounded to a powerOfTwo of 0 yields
        1.0, and 1.3 rounded to a powerOfTwo of 2 yields 1.25.
        
        ### Collection([T(32, 192, 16)], 64).round()
        Ranges: [(1, 4, 1)]
        ### Collection([T(32, 192, 16)], 64).round(1)
        Ranges: [(0.5, 3.5, 0.5)]
        """
        
        return self.convertToBasis(2 ** powerOfTwo, round=True)
    
    def signedParts(self):
        """
        Returns two Collections: one with only the negative values and one with
        only the non-negative values. If either or both of these are empty,
        None is returned in its place.
        
        ### Collection([T(-20, 10, 3), T(200, None, 50)]).signedParts()
        (Ranges: [(-20, 1, 3)], Ranges: [(1, 10, 3), (200, *, 50)])
        """
        
        # I would love to do the following with iterators, but I couldn't
        # figure out a way of getting around the fact that one assignment has
        # to be completely done before another starts (assuming I only ever
        # want to do the signedParts() call once per member Triple).
        #
        # It may be that coroutines (using new generator functionality present
        # in Python since 2.5) would permit this, but I'll have to figure out
        # how that might work at some point in the future.
        #
        # And doing this with threads would just be ridiculous.
        
        vNeg, vPos = [], []
        
        for t in self.tripleIterator():
            tNeg, tPos = t.signedParts()
            
            if tNeg is not None:
                vNeg.append(tNeg)
            
            if tPos is not None:
                vPos.append(tPos)
        
        cNeg = (Collection(vNeg, self.basis) if vNeg else Collection())
        cPos = (Collection(vPos, self.basis) if vPos else Collection())
        return (cNeg, cPos)
    
    def toNumber(self, raiseException=False):
        """
        If the Collection contains only a single element then that element is
        returned. If it has no elements, or more than one, then None is
        returned if raiseException is False, or a ValueError is raised if
        raiseException is True.
        
        ### Collection([T(1, 2, 1)]).toNumber()
        1
        ### Collection([T(1, 2, 1)], 4).toNumber()
        0.25
        ### print(Collection([T(1, 11, 2)]).toNumber())
        None
        ### Collection([T(1, 11, 2)]).toNumber(True)
        Traceback (most recent call last):
          ...
        ValueError: Collection has more than one member!
        """
        
        if self._cachedLen is None or self._cachedLen != 1:
            if raiseException:
                raise ValueError("Collection has more than one member!")
            else:
                return None
        
        return next(iter(self))
    
    def tripleIterator(self):
        """
        Returns an iterator over all the member Triples, in sorted order. Note
        that these are always assumed to be basis 1.
        
        ### tc = Collection([T(1, 11, 2), T(35, None, 8)])
        ### it = tc.tripleIterator()
        ### next(it)
        (1, 11, 2)
        ### next(it)
        (35, *, 8)
        ### next(it)
        Traceback (most recent call last):
          ...
        StopIteration
        """
        
        for key in sorted(self.d):
            for t in self.d[key]:
                yield t

# -----------------------------------------------------------------------------

#
# Delayed module imports
#

from fontio3.triple import triple, utilities

T = triple.Triple

# -----------------------------------------------------------------------------

#
# Test code
#

if 0:
    def __________________(): pass

def _test_main():
    """
    Run integrated tests for the whole module.
    
    ### tc = Collection([T(15, None, 4)])
    ### tc
    Ranges: [(15, *, 4)]
    ### tc2 = copy.deepcopy(tc)
    ### tc2
    Ranges: [(15, *, 4)]
    ### tc is tc2
    False
    ### tc.d is tc2.d
    False
    ### tc.d[(4, 3)] is tc2.d[(4, 3)]
    False
    """
    
    pass

def _test():
    import doctest
    doctest.testmod()

if __name__ == "__main__":
    _test()

