#
# triple.py
#
# Copyright Â© 2007-2011 Monotype Imaging Inc. All Rights Reserved.
#

"""
Objects representing spans of integer values similar to those generated by
the range function.
"""

# System imports
import operator

# Other imports
from fontio3.fontmath import rational

# -----------------------------------------------------------------------------

#
# Constants
#

# The following dictionary maps tuples ((a, b), (c, d)) to strings, and is
# used by Triple.positionsHowWithRespectTo. The interpretations of a,b,c,d is:
#
#   a = cmp(self.start, other.start)
#   b = cmp(self.start, other.stop)
#   c = cmp(self.stop, other.start)
#   d = cmp(self.stop, other.stop)

relativePositionsMap = {
  ((-1, -1), (-1, -1)): "disjointLeft",
  ((-1, -1), (0, -1)): "extendsOnLeft",
  ((-1, -1), (0, 0)): "contains",           # degenerate case
  ((-1, -1), (1, -1)): "extendsOnLeft",
  ((-1, -1), (1, 0)): "contains",
  ((-1, -1), (1, 1)): "contains",
  ((0, -1), (0, -1)): "isContainedBy",      # degenerate case
  ((0, -1), (1, -1)): "isContainedBy",
  ((0, -1), (1, 0)): "contains",
  ((0, -1), (1, 1)): "contains",
  ((0, 0), (0, 0)): "contains",             # degenerate case
  ((0, 0), (1, 1)): "contains",             # degenerate case
  ((1, -1), (1, -1)): "isContainedBy",
  ((1, -1), (1, 0)): "isContainedBy",
  ((1, -1), (1, 1)): "extendsOnRight",
  ((1, 0), (1, 0)): "isContainedBy",        # degenerate case
  ((1, 0), (1, 1)): "extendsOnRight",
  ((1, 1), (1, 1)): "disjointRight"}

# -----------------------------------------------------------------------------

#
# Classes
#

class Triple(object):
    """
    Objects compactly representing a lattice of integer values, uniformly
    spaced. They are analogous to python slices.
    
    Triples may be either closed or open. An open Triple is signified by a
    start and/or stop value of None, indicating an open end.
    
    Triples are immutable, so they're OK to use as dict keys or in sets.
    """
    
    #
    # Initialization method
    #
    
    def __init__(self, start, stop, skip, phase=None):
        """
        Initializes the triple. For closed Triples, makes sure the values are
        in canonical form, where skip is always positive, and where stop -
        start is always an exact multiple of skip.

        For double-open Triples, the phase controls the modulus for skips
        greater than one. If it defaults to None, it will be set to 0.
        
        >>> Triple(1, 11, 2), Triple(1, 10, 2)
        ((1, 11, 2), (1, 11, 2))
        >>> Triple(10, 2, -2), Triple(11, 2, -2)
        ((4, 12, 2), (3, 13, 2))
        >>> Triple(1, 1, 1)
        (1, 1, 1)
        >>> Triple(None, 10, 4)
        (*, 10, 4)
        >>> Triple(None, None, 3, 1)
        (*, *, 3, phase=1)
        >>> Triple(1, 4, 0)
        Traceback (most recent call last):
          ...
        ValueError: Skip cannot be zero!
        >>> Triple(1, 11, -2)
        Traceback (most recent call last):
          ...
        ValueError: Stop cannot be greater than start for negative skip!
        >>> Triple(10, 0, 4)
        Traceback (most recent call last):
          ...
        ValueError: Start cannot be greater than stop for positive skip!
        """
        
        if skip == 0:
            raise ValueError("Skip cannot be zero!")
        
        if start is None or stop is None:
            skip = abs(skip)
            
            if start is None and stop is None:
                if phase is None: phase = 0
            elif start is None:
                phase = stop % skip
            else:
                phase = start % skip
            
            t = (start, stop, skip, None, phase)
        
        elif skip > 0:
            if start > stop:
                raise ValueError("Start cannot be greater than stop for positive skip!")
            
            tLen = (stop - start + (skip - 1)) // skip
            t = (start, start + tLen * skip, skip, tLen, start % skip)
        
        else:
            if stop > start:
                raise ValueError("Stop cannot be greater than start for negative skip!")
            
            tLen = (stop - start + 1 + skip) // skip
            newStop = start - skip
            t = (newStop + tLen * skip, newStop, -skip, tLen, start % -skip)
        
        self.start, self.stop, self.skip, self._cachedLen, self.phase = t
    
    #
    # Special methods
    #
    
    def __contains__(self, n):
        """
        Returns True if n is a member of the Triple. If n is None, returns True
        if the Triple is open-ended and False otherwise; this means you can use
        'None in t' to see if a Triple is open-ended.
        
        Membership tests respect the phase for open-ended Triples.
        
        >>> 15 in Triple(4, 37, 11)
        True
        >>> 16 in Triple(4, 37, 11)
        False
        >>> 37 in Triple(4, 37, 11)
        False
        >>> -7 in Triple(4, 37, 11)
        False
        >>> None in Triple(4, 37, 11)
        False
        >>> None in Triple(12, None, 3)
        True
        >>> 8 in Triple(None, 16, 2)
        True
        >>> 8 in Triple(16, None, 2)
        False
        """
        
        if n is None:
            return self._cachedLen is None
        
        if n % self.skip != self.phase:
            return False
        
        # The phase matches, so just do a limit check
        return (
          (self.start is None or n >= self.start) and
          (self.stop is None or n < self.stop))
    
    def __deepcopy__(self, memo=None):
        """
        Returns a copy of the Triple (deep and shallow copies are the same for
        Triples).
        
        >>> t1 = Triple(1, 11, 2)
        >>> t2 = t1.__deepcopy__()
        >>> t1 is t2
        False
        >>> t1 == t2
        True
        """
        
        return type(self)(self.start, self.stop, self.skip, self.phase)
    
    def __eq__(self, other):
        """
        Returns if self equals other (which may be either a Triple or an
        integer).
        
        >>> Triple(1, 11, 2) == Triple(1, 11, 2)
        True
        >>> Triple(1, 11, 2) == Triple(1, 13, 2)
        False
        >>> Triple(3, 4, 1) == 3
        True
        >>> Triple(2, 12, 2) == 19
        False
        """
        
        if self is other:
            return True
        
        try:
            return self.__dict__ == other.__dict__
        except AttributeError:
            return (self.start == other if self._cachedLen == 1 else False)
    
    def __float__(self):
        """
        If the Triple has a single element, this method returns the
        floating-point value of that element. Otherwise this method raises a
        ValueError.
        
        >>> float(Triple(4, 6, 2))
        4.0
        >>> float(Triple(1, 11, 2))
        Traceback (most recent call last):
          ...
        ValueError: Triple must have exactly one member to get float!
        """
        
        if self._cachedLen == 1:
            return float(self.start)
        
        raise ValueError("Triple must have exactly one member to get float!")
    
    def __hash__(self):
        """
        Returns a hash value for the Triple.
        
        >>> hash(Triple(1, 11, 2)) != hash(Triple(1, 11, 1))
        True
        >>> hash(Triple(1, 1, 1)) == hash(Triple(4, 4, 12))
        True
        >>> hash(Triple(4, 5, 1)) == hash(Triple(4, 8, 4))
        True
        """
        
        if self._cachedLen == 0:
            return hash(())  # all zero-length Triples are essentially the same
        
        if self._cachedLen == 1:
            return self.start
        
        return hash((self.start, self.stop, self.skip, self.phase))
    
    def __int__(self):
        """
        If the Triple has a single element, this method returns the integer
        value of that element. Otherwise this method raises a ValueError.
        
        >>> int(Triple(4, 6, 2))
        4
        >>> int(Triple(1, 11, 2))
        Traceback (most recent call last):
          ...
        ValueError: Triple must have exactly one member to get int!
        """
        
        if self._cachedLen == 1:
            return self.start
        
        raise ValueError("Triple must have exactly one member to get int!")
    
    def __invert__(self):
        """
        Returns a Triple whose values are the bitwise inverse of the original
        values.
        
        >>> ~Triple(1, 11, 2)
        (-10, 0, 2)
        >>> ~Triple(15, None, 4)
        (*, -12, 4)
        >>> ~Triple(None, 233, 187)
        (-47, *, 187)
        >>> ~Triple(None, None, 10, 8)
        (*, *, 10, phase=1)
        """
        
        newStart = (None if self.stop is None else self.skip - self.stop - 1)
        newStop = (None if self.start is None else self.skip - self.start - 1)
        
        if newStart is None and newStop is None:
            return Triple(None, None, self.skip, self.skip - self.phase - 1)
        
        return Triple(newStart, newStop, self.skip)
    
    def __iter__(self):
        """
        If the Triple is closed on both ends, then this method returns an
        iterator over the values in the Triple. If the Triple is open on one or
        both ends, this method raises a ValueError.
        
        >>> list(Triple(3, 12, 3))
        [3, 6, 9]
        >>> next(iter(Triple(4, None, 2)))
        Traceback (most recent call last):
          ...
        ValueError: Use openIterator() to iterate open-ended Triples.
        """
        
        if self._cachedLen is None:
            raise ValueError("Use openIterator() to iterate open-ended Triples.")
        
        n, limit, delta = self.start, self.stop, self.skip
        
        while n < limit:
            yield n
            n += delta
    
    def __len__(self):
        """
        If the Triple is closed on both ends, then this method returns the
        number of entries contained in the Triple. If the Triple is open on one
        or both ends, this method raises a ValueError.
        
        >>> len(Triple(3, 8, 1))
        5
        >>> len(Triple(10, 40, 15))
        2
        >>> len(Triple(None, 5, 3))
        Traceback (most recent call last):
          ...
        ValueError: Open-ended Triples have infinite length!
        """
        
        if self._cachedLen is None:
            raise ValueError("Open-ended Triples have infinite length!")
        
        return self._cachedLen
    
    def __ne__(self, other): return not (self == other)
    
    def __neg__(self):
        """
        Returns a Triple whose values are the negative of the original values.
        
        >>> -Triple(None, None, 7, 4)
        (*, *, 7, phase=3)
        >>> -Triple(None, 90, 7)
        (-83, *, 7)
        >>> -Triple(-83, None, 7)
        (*, 90, 7)
        >>> -Triple(-88, 200, 12)
        (-188, 100, 12)
        """
        
        if self.start is None:
            if self.stop is None:
                return Triple(None, None, self.skip, (self.skip - self.phase) % self.skip)
            return Triple(self.skip - self.stop, None, self.skip)
        elif self.stop is None:
            return Triple(None, self.skip - self.start, self.skip)
        return Triple(self.skip - self.stop, self.skip - self.start, self.skip)
    
    def __bool__(self):
        """
        Returns True if there is content present in the Triple.
        
        >>> bool(Triple(1, 11, 2))
        True
        >>> bool(Triple(1, 1, 1))
        False
        >>> bool(Triple(None, 12, 1))
        True
        """
        
        return self._cachedLen != 0
    
    def __pos__(self): return self
    
    def __repr__(self):
        """
        Returns a string representation of the Triple. For closed triples this
        looks like a tuple (start, stop, skip). For open triples the format
        varies.
        """
        
        if self._cachedLen is not None:
            return "(%d, %d, %d)" % (self.start, self.stop, self.skip)
        
        if self.start is None:
            if self.stop is None:
                return "(*, *, %d, phase=%d)" % (self.skip, self.phase)
            
            return "(*, %d, %d)" % (self.stop, self.skip)
        
        return "(%d, *, %d)" % (self.start, self.skip)
    
    #
    # Private methods
    #
    
    _dispatch = {
      'abs': None,
      'add': None,
      'and': None,
      'cmpInf': None,
      'convert': None,
      'div': None,
      'lshift': None,
      'mod': None,
      'mul': None,
      'pow': None,
      'rshift': None,
      'xor': None}
    
    def _fillDispatch(self):
        from fontio3.triple import (
          absOps, addOps, andOps, basisOps, divOps, lshiftOps, modOps, mulOps,
          powOps, rshiftOps, utilities, xorOps)
        
        d = self._dispatch
        d['abs'] = absOps.absOp
        d['add'] = addOps.addOp
        d['and'] = andOps.andOp
        d['cmpInf'] = utilities.cmpInf
        d['convert'] = basisOps.convert
        d['div'] = divOps.divOp
        d['lshift'] = lshiftOps.lshiftOp
        d['mod'] = modOps.modOp
        d['mul'] = mulOps.mulOp
        d['pow'] = powOps.powOp
        d['rshift'] = rshiftOps.rshiftOp
        d['xor'] = xorOps.xorOp
    
    #
    # Public methods
    #
    
    def abs(self):
        """
        Returns an iterator of Triples representing the absolute value of the
        input Triple. This is public, and not the __abs__ special method,
        because it returns an iterator and not just a single Triple.

        No particular attempt is made to optimize the return result. A client
        wishing for such optimizations should pass the iterator returned by
        this method into the constructor for the Collection class.
        
        >>> list(Triple(None, None, 3, 0).abs())
        [(0, *, 3)]
        >>> list(Triple(None, None, 5, 1).abs())
        [(1, *, 5), (4, *, 5)]
        >>> list(Triple(None, -8, 5).abs())
        [(13, *, 5)]
        >>> list(Triple(None, 23, 8).abs())
        [(7, 23, 8), (1, *, 8)]
        >>> list(Triple(1, None, 8).abs())
        [(1, *, 8)]
        >>> list(Triple(-19, None, 4).abs())
        [(3, 23, 4), (1, *, 4)]
        >>> list(Triple(-21, None, 6).abs())
        [(3, *, 6)]
        >>> list(Triple(4, 104, 25).abs())
        [(4, 104, 25)]
        >>> list(Triple(-126, 2, 16).abs())
        [(14, 142, 16)]
        >>> list(Triple(-126, 162, 16).abs())
        [(14, 142, 16), (2, 162, 16)]
        >>> list(Triple(-26, 26, 4).abs())
        [(2, 30, 4)]
        """
        
        f = self._dispatch['abs']
        
        if f is None:
            self._fillDispatch()
            f = self._dispatch['abs']
        
        return f(self)
    
    def add(self, other):
        """
        Returns an iterator of Triples representing the sum of self and other
        (which may be another Triple or a simple integer). This is public, and
        not the __add__ special method, because it returns an iterator and not
        just a single Triple.

        No particular attempt is made to optimize the return result. A client
        wishing for such optimizations should pass the iterator returned by
        this method into the constructor for the Collection class.
        
        >>> list(Triple(13, 43, 5).add(6))
        [(19, 49, 5)]
        >>> list(Triple(None, None, 6, phase=2).add(Triple(None, None, 9, phase=2)))
        [(*, *, 3, phase=1)]
        >>> list(Triple(None, None, 6, phase=2).add(Triple(None, 19, 9)))
        [(*, *, 3, phase=0)]
        >>> list(Triple(None, None, 6, phase=2).add(Triple(19, None, 9)))
        [(*, *, 3, phase=0)]
        >>> list(Triple(None, None, 6, phase=2).add(Triple(4, 12, 8)))
        [(*, *, 6, phase=0)]
        >>> list(Triple(None, 19, 6).add(Triple(None, None, 7, phase=4)))
        [(*, *, 1, phase=0)]
        >>> list(Triple(None, 19, 6).add(Triple(None, 11, 2)))
        [(*, 24, 2)]
        >>> list(Triple(None, 19, 6).add(Triple(11, None, 2)))
        [(*, *, 2, phase=0)]
        >>> list(Triple(None, 19, 6).add(Triple(30, 60, 5)))
        [(*, 45, 1), (45, 55, 5), (46, 61, 5), (47, 67, 5), (48, 73, 5)]
        >>> list(Triple(8, None, 12).add(Triple(None, None, 16, phase=5)))
        [(*, *, 4, phase=1)]
        >>> list(Triple(8, None, 12).add(Triple(None, -50, 16)))
        [(*, *, 4, phase=2)]
        >>> list(Triple(8, None, 12).add(Triple(-50, None, 16)))
        [(-10, *, 4), (-26, -2, 12), (-42, -6, 12)]
        >>> list(Triple(8, None, 12).add(Triple(-100, 2500, 8)))
        [(-80, *, 4), (-92, -76, 8)]
        >>> list(Triple(1, 9, 2).add(Triple(None, None, 19, phase=16)))
        [(*, *, 19, phase=17), (*, *, 19, phase=0), (*, *, 19, phase=2), (*, *, 19, phase=4)]
        """
        
        f = self._dispatch['add']
        
        if f is None:
            self._fillDispatch()
            f = self._dispatch['add']
        
        return f(self, other)
    
    def and_(self, other):
        """
        Returns an iterator of Triples representing the bitwise-AND of self and
        other (which may be another Triple or a simple integer). This is
        public, and not the __and__ special method, because it returns an
        iterator and not just a single Triple.

        No particular attempt is made to optimize the return result. A client
        wishing for such optimizations should pass the iterator returned by
        this method into the constructor for the Collection class.
        """
        
        f = self._dispatch['and']
        
        if f is None:
            self._fillDispatch()
            f = self._dispatch['and']
        
        return f(self, other)
    
    def asImmutable(self, **kwArgs):
        """
        Returns a tuple (start, stop, skip, phase).
        
        >>> Triple(1, 11, 2).asImmutable()
        (1, 11, 2, 1)
        >>> Triple(None, None, 5, 3).asImmutable()
        (None, None, 5, 3)
        """
        
        return (self.start, self.stop, self.skip, self.phase)
    
    def basisToBasis(self, oldBasis, newBasis, round=True):
        """
        Triples do not themselves have basis values; however, when they are
        members of a Collection they do. This method returns an iterator over
        Triples representing the rounded conversion of self as if it were
        oldBasis into newBasis.
        """
        
        assert oldBasis >= 1 and newBasis >= 1, "Basis values must be >= 1!"
        f = self._dispatch['convert']
        
        if f is None:
            self._fillDispatch()
            f = self._dispatch['convert']
        
        return f(self, oldBasis, newBasis, round)
    
    def difference(self, other):
        """
        Returns an iterator over Triples whose values are Triples representing
        the "set" difference resulting when other is subtracted from self.
        
        >>> list(Triple(1, 11, 2).difference(Triple(-41, -11, 2)))
        [(1, 11, 2)]
        >>> list(Triple(1, 11, 2).difference(Triple(13, 43, 2)))
        [(1, 11, 2)]
        >>> list(Triple(1, 11, 2).difference(Triple(-51, 51, 2)))
        []
        >>> list(Triple(1, 11, 2).difference(Triple(11, 21, 2)))
        [(1, 11, 2)]
        >>> list(Triple(1, 11, 2).difference(Triple(-11, 5, 2)))
        [(5, 11, 2)]
        >>> list(Triple(1, 11, 2).difference(Triple(-11, 1, 2)))
        [(1, 11, 2)]
        >>> list(Triple(1, 11, 2).difference(Triple(7, 47, 2)))
        [(1, 7, 2)]
        >>> list(Triple(1, 11, 2).difference(Triple(1, 5, 2)))
        [(5, 11, 2)]
        >>> list(Triple(1, 11, 2).difference(Triple(3, 7, 2)))
        [(1, 3, 2), (7, 11, 2)]
        >>> list(Triple(1, 11, 2).difference(Triple(5, 11, 2)))
        [(1, 5, 2)]
        >>> list(Triple(1, 121, 6).difference(Triple(25, None, 4)))
        [(1, 25, 6), (115, 121, 6), (31, 115, 12)]
        >>> list(Triple(1, 101, 2).difference(Triple(1, 101, 5)))
        [(93, 101, 2), (3, 93, 10), (5, 95, 10), (7, 97, 10), (9, 99, 10)]
        >>> list(Triple(None, 12, 2).difference(Triple(None, 12, 2)))
        []
        >>> list(Triple(None, 16, 2).difference(Triple(None, 12, 2)))
        [(12, 16, 2)]
        """
        
        selfKey = (self.skip, self.phase)
        otherKey = (other.skip, other.phase)
        
        if selfKey == otherKey:
            location = self.positionsHowWithRespectTo(other)
            
            if location in ('disjointLeft', 'disjointRight'):
                yield self  # no intersection
            
            elif location == 'isContainedBy':
                pass  # difference is empty
            
            elif location == 'extendsOnLeft':
                yield Triple(self.start, other.start, self.skip)
            
            elif location == 'extendsOnRight':
                yield Triple(other.stop, self.stop, self.skip)
            
            else:
                # self contains other
                if self.start is None and self.stop is None:
                    if other.stop is not None:
                        yield Triple(other.stop, None, self.skip)
                
                elif self.start is None:
                    if other.start is None:
                        if self.stop > other.stop:
                            yield Triple(other.stop, self.stop, self.skip)
                    
                    else:
                        yield Triple(None, other.start, self.skip)
                        
                        if self.stop > other.stop:
                            yield Triple(other.stop, self.stop, self.skip)
                
                elif self.stop is None:
                    if other.stop is None:
                        if self.start < other.start:
                            yield Triple(self.start, other.start, self.skip)
                    
                    else:
                        if self.start < other.start:
                            yield Triple(self.start, other.start, self.skip)
                        
                        yield Triple(other.stop, None, self.skip)
                
                else:
                    part1Stop = other.start
                    part2Start = other.stop
                    
                    if part1Stop > self.start:
                        yield Triple(self.start, part1Stop, self.skip)
                    
                    if part2Start < self.stop:
                        yield Triple(part2Start, self.stop, self.skip)
        
        elif self.stop is not None and other.start is not None and self.stop <= other.start:
            yield self
        
        elif self.start is not None and other.stop is not None and self.start >= other.stop:
            yield self
        
        else:
            # Call findMember to find any pieces of self completely outside
            # other; only do the "sliceBySkip" trick for the actual
            # intersecting pieces
            sect = self.intersection(other)
            
            if sect is None:
                yield self
            
            else:
                if sect.start is not None:
                    if self.start is None or sect.start > self.start:
                        yield Triple(self.start, sect.start, self.skip)
                        self = Triple(sect.start, self.stop, self.skip)
                
                if sect.stop is not None:
                    firstAfter = sect.stop - sect.skip + self.skip
                    
                    if self.stop is None or firstAfter < self.stop:
                        yield Triple(firstAfter, self.stop, self.skip)
                        self = Triple(self.start, firstAfter, self.skip)
                
                lcm = rational.lcm(self.skip, other.skip)
                d = dict((t.phase, t) for t in other.sliceBySkip(lcm))
                
                for t in self.sliceBySkip(lcm):
                    if t.phase in d:
                        for tSect in t.difference(d[t.phase]):
                            yield tSect
                    else:
                        yield t
    
    def div(self, other):
        """
        Returns an iterator of Triples representing the truncating (i.e.
        integer) division of self and other (which may be another Triple or a
        simple integer). This is public, and not the __div__ special method,
        because it returns an iterator and not just a single Triple.

        No particular attempt is made to optimize the return result. A client
        wishing for such optimizations should pass the iterator returned by
        this method into the constructor for the Collection class.
        """
        
        f = self._dispatch['div']
        
        if f is None:
            self._fillDispatch()
            f = self._dispatch['div']
        
        return f(self, other)
    
    def findMember(self, largestLessThan, orEqual, n):
        """
        Returns the value of self meeting the specified criteria. The opposite
        of largestLessThan can be thought of as smallestGreaterThan.
        
        If no such member can be found, None is returned.
        
        >>> t = Triple(2, 37, 7)
        >>> [t.findMember(a, b, 19) for a in range(2) for b in range(2)]
        [23, 23, 16, 16]
        >>> [t.findMember(a, b, 16) for a in range(2) for b in range(2)]
        [23, 16, 9, 16]
        >>> [t.findMember(a, b, -5) for a in range(2) for b in range(2)]
        [2, 2, None, None]
        >>> [t.findMember(a, b, 34) for a in range(2) for b in range(2)]
        [None, None, 30, 30]
        >>> [t.findMember(a, b, 2) for a in range(2) for b in range(2)]
        [9, 2, None, 2]
        >>> [t.findMember(a, b, 30) for a in range(2) for b in range(2)]
        [None, 30, 23, 30]
        """
        
        if largestLessThan:
            if self.start is not None:
                op = (operator.lt if orEqual else operator.le)
                
                if op(n, self.start):
                    return None
            
            if self.stop is not None:
                op = (operator.ge if orEqual else operator.gt)
                
                if op(n, self.stop - self.skip):
                    return self.stop - self.skip
            
            adj = (n - self.phase) % self.skip
            return n - adj - (0 if adj or orEqual else self.skip)
        
        if self.start is not None:
            op = (operator.le if orEqual else operator.lt)
            
            if op(n, self.start):
                return self.start
        
        if self.stop is not None:
            op = (operator.gt if orEqual else operator.ge)
            
            if op(n, self.stop - self.skip):
                return None
        
        adj = self.skip - (n - self.phase) % self.skip
        
        if orEqual:
            adj = adj % self.skip
        
        return n + adj
    
    def intersection(self, other):
        """
        Returns a Triple representing the intersection of self and other, or
        None if they do not intersect.
        
        >>> Triple(1, 11, 2).intersection(Triple(3, 6, 1))
        (3, 7, 2)
        >>> Triple(1, 13, 4).intersection(Triple(9, 49, 4))
        (9, 13, 4)
        >>> Triple(4, 34, 3).intersection(Triple(1, 31, 6))
        (7, 31, 6)
        >>> Triple(4, 34, 3).intersection(Triple(3, 33, 6)) is None
        True
        >>> Triple(4, 7, 3).intersection(Triple(1, 31, 6)) is None
        True
        >>> Triple(1, 10, 1).intersection(Triple(10, 20, 1)) is None
        True
        >>> Triple(None, 20, 1).intersection(Triple(10, 30, 1))
        (10, 20, 1)
        >>> Triple(None, 68, 6).intersection(Triple(23, None, 9))
        (32, 68, 18)
        >>> Triple(None, 14, 2).intersection(Triple(None, 28, 7))
        (*, 14, 14)
        >>> Triple(None, None, 2, 1).intersection(Triple(None, None, 2, 1))
        (*, *, 2, phase=1)
        >>> Triple(None, None, 5, 2).intersection(Triple(None, None, 10, 7))
        (*, *, 10, phase=7)
        """
        
        gcf = rational.gcf(self.skip, other.skip)
        lcm = (self.skip * other.skip) // gcf
        
        if self.phase % gcf != other.phase % gcf:
            return None
        
        firsts, lasts = [], []
        
        for x, y in ((self, other), (other, self)):
            thisStart = x.start
            
            if thisStart is not None:
                while thisStart % y.skip != y.phase:
                    thisStart += x.skip
                
                if x.stop is not None and thisStart >= x.stop:
                    return None
                
                firsts.append(thisStart)
            
            if x.stop is not None:
                thisLast = x.stop - x.skip
                
                while thisLast % y.skip != y.phase:
                    thisLast -= x.skip
                
                if x.start is not None and thisLast < x.start:
                    return None
                
                lasts.append(thisLast)
        
        thisStart = (max(firsts) if firsts else None)
        thisStop = (min(lasts) + lcm if lasts else None)
        
        if thisStart is not None and thisStop is not None and thisStart >= thisStop:
            return None
        
        if thisStart is None and thisStop is None:
            newPhase = (self.phase if self.skip >= other.skip else other.phase)
        else:
            newPhase = None
        
        return Triple(thisStart, thisStop, lcm, newPhase)
    
    def lshift(self, other):
        """
        Returns an iterator over Triples representing the logical left-shift of
        self by other (which may be another Triple or a simple integer). This
        is public, and not the __lshift__ special method, because it returns an
        iterator and not just a single Triple.

        No particular attempt is made to optimize the return result. A client
        wishing for such optimizations should pass the iterator returned by
        this method into the constructor for the Collection class.
        """
        
        f = self._dispatch['lshift']
        
        if f is None:
            self._fillDispatch()
            f = self._dispatch['lshift']
        
        return f(self, other)
    
    def mod(self, other):
        """
        Returns an iterator over Triples representing the modulus of self by
        other (which may be another Triple or a simple integer). This is
        public, and not the __mod__ special method, because it returns an
        iterator and not just a single Triple.

        No particular attempt is made to optimize the return result. A client
        wishing for such optimizations should pass the iterator returned by
        this method into the constructor for the Collection class.
        """
        
        f = self._dispatch['mod']
        
        if f is None:
            self._fillDispatch()
            f = self._dispatch['mod']
        
        return f(self, other)
    
    def mul(self, other):
        """
        Returns an iterator of Triples representing the product of self and
        other (which may be another Triple or a simple integer). This is
        public, and not the __mul__ special method, because it returns an
        iterator and not just a single Triple.

        No particular attempt is made to optimize the return result. A client
        wishing for such optimizations should pass the iterator returned by
        this method into the constructor for the Collection class.
        """
        
        f = self._dispatch['mul']
        
        if f is None:
            self._fillDispatch()
            f = self._dispatch['mul']
        
        return f(self, other)
    
    def openIterator(self):
        """
        Returns a generator over self, even if self is open-ended. In this case
        the client is responsible for terminating loops, since StopIteration
        will never be raised.
        
        Open Triples count from their fixed ends, up or down as indicated.
        Doubly-open Triples return interlaced values starting from the phase;
        see the example below.
        
        >>> it = Triple(1, 11, 2).openIterator()
        >>> list(it)
        [1, 3, 5, 7, 9]
        >>> it = Triple(15, None, 4).openIterator()
        >>> [next(it) for i in range(10)]
        [15, 19, 23, 27, 31, 35, 39, 43, 47, 51]
        >>> it = Triple(None, None, 10, phase=4).openIterator()
        >>> [next(it) for i in range(10)]
        [4, -6, 14, -16, 24, -26, 34, -36, 44, -46]
        """
        
        if self.start is None:
            if self.stop is None:
                goingUp = self.phase
                goingDown = self.phase - self.skip
                while True:
                    yield goingUp
                    yield goingDown
                    goingUp += self.skip
                    goingDown -= self.skip
            else:
                goingDown = self.stop - self.skip
                while True:
                    yield goingDown
                    goingDown -= self.skip
        elif self.stop is None:
            goingUp = self.start
            while True:
                yield goingUp
                goingUp += self.skip
        else:
            for n in range(self.start, self.stop, self.skip):
                yield n
    
    def or_(self, other):
        """
        Instead of having to separately implement the bitwise-OR operation, we
        use DeMorgan's Law which states that A | B = ~(~A & ~B), and just use the
        existing __invert__ and and_ methods.
        """
        
        for t in (~self).and_(~other):
            yield ~t

    def positionsHowWithRespectTo(self, other):
        """
        Returns a string describing how self is positioned with respect to
        other. A ValueError is raised if the skip and phase of the two Triples
        are not the same.

        The returned string will be one of the following (note that two equal
        Triples will return 'contains', even though 'isContainedBy' is also
        technically correct):
        
            contains            Indicates self completely contains other (i.e.
                                their union exactly equals self).
            
            disjointLeft        Indicates self's position on the number line is
                                strictly to the left of other's position, and
                                the two cannot be merged.
            
            disjointRight       Indicates self's position on the number line is
                                strictly to the right of other's position, and
                                the two cannot be merged.
            
            extendsOnLeft       Indicates self and other overlap, but self's
                                start on the number line is to the left of
                                other's start.
            
            extendsOnRight      Indicates self and other overlap, but self's
                                start on the number line is to the right of
                                other's start.
            
            isContainedBy       Indicates self is completely contained by other
                                (i.e. their union exactly equals other).
        
        >>> Triple(3, 8, 1).positionsHowWithRespectTo(Triple(15, 25, 1))
        'disjointLeft'
        >>> Triple(3, 8, 1).positionsHowWithRespectTo(Triple(6, 25, 1))
        'extendsOnLeft'
        >>> Triple(3, 8, 1).positionsHowWithRespectTo(Triple(1, 25, 1))
        'isContainedBy'
        >>> Triple(3, 8, 1).positionsHowWithRespectTo(Triple(5, 7, 1))
        'contains'
        >>> Triple(None, 14, 1).positionsHowWithRespectTo(Triple(20, 30, 1))
        'disjointLeft'
        >>> Triple(None, 20, 1).positionsHowWithRespectTo(Triple(20, 30, 1))
        'extendsOnLeft'
        >>> Triple(None, 50, 1).positionsHowWithRespectTo(Triple(20, 30, 1))
        'contains'
        >>> Triple(25, None, 1).positionsHowWithRespectTo(Triple(1, 18, 1))
        'disjointRight'
        >>> Triple(25, None, 1).positionsHowWithRespectTo(Triple(1, 200, 1))
        'extendsOnRight'
        >>> Triple(-40, None, 1).positionsHowWithRespectTo(Triple(1, 18, 1))
        'contains'
        """
        
        if self.skip != other.skip or self.phase != other.phase:
            if self._cachedLen != 1 or other._cachedLen != 1:
                raise ValueError(
                  "Triples provided to positionsHowWithRespectTo must match in skip and phase!")
        
        selfStart = ("-inf" if self.start is None else self.start)
        selfStop = ("+inf" if self.stop is None else self.stop)
        otherStart = ("-inf" if other.start is None else other.start)
        otherStop = ("+inf" if other.stop is None else other.stop)
        cmpInf = self._dispatch['cmpInf']
        
        if cmpInf is None:
            self._fillDispatch()
            cmpInf = self._dispatch['cmpInf']
        
        a = cmpInf(selfStart, otherStart)
        b = cmpInf(selfStart, otherStop)
        c = cmpInf(selfStop, otherStart)
        d = cmpInf(selfStop, otherStop)
        return relativePositionsMap[((a, b), (c, d))]
    
    def pow_(self, other):
        """
        Returns an iterator of Triples representing self raised to power of
        other (which may be another Triple or a simple integer). This is
        public, and not the __pow__ special method, because it returns an
        iterator and not just a single Triple.

        No particular attempt is made to optimize the return result. A client
        wishing for such optimizations should pass the iterator returned by
        this method into the constructor for the Collection class.
        """
        
        f = self._dispatch['pow']
        
        if f is None:
            self._fillDispatch()
            f = self._dispatch['pow']
        
        return f(self, other)
    
    def rshift(self, other):
        """
        Returns an iterator over Triples representing the logical right-shift
        of self by other (which may be another Triple or a simple integer).
        This is public, and not the __rshift__ special method, because it
        returns an iterator and not just a single Triple.

        No particular attempt is made to optimize the return result. A client
        wishing for such optimizations should pass the iterator returned by
        this method into the constructor for the Collection class.
        """
        
        f = self._dispatch['rshift']
        
        if f is None:
            self._fillDispatch()
            f = self._dispatch['rshift']
        
        return f(self, other)
    
    def signedParts(self):
        """
        Returns a pair, the first element of which is a Triple containing only
        the negative values of self, and the second element of which is a
        Triple containing only the non-negative values. If one (or both) parts
        are empty, None is returned as that element of the pair.
        
        >>> Triple(None, None, 5, 1).signedParts()
        ((*, 1, 5), (1, *, 5))
        >>> Triple(None, -45, 2).signedParts()
        ((*, -45, 2), None)
        >>> Triple(None, 38, 12).signedParts()
        ((*, 2, 12), (2, 38, 12))
        >>> Triple(20, None, 5).signedParts()
        (None, (20, *, 5))
        >>> Triple(-20, None, 5).signedParts()
        ((-20, 0, 5), (0, *, 5))
        >>> Triple(15, 55, 4).signedParts()
        (None, (15, 55, 4))
        >>> Triple(-100, -40, 3).signedParts()
        ((-100, -40, 3), None)
        >>> Triple(-100, 50, 5).signedParts()
        ((-100, 0, 5), (0, 50, 5))
        """
        
        if self.start is None:
            if self.stop is None:
                return (Triple(None, self.phase, self.skip), Triple(self.phase, None, self.skip))
            
            if self.stop - self.skip < 0:
                return (self, None)
            
            return (Triple(None, self.phase, self.skip), Triple(self.phase, self.stop, self.skip))
        
        if self.stop is None:
            if self.start >= 0:
                return (None, self)
            
            return (Triple(self.start, self.phase, self.skip), Triple(self.phase, None, self.skip))
        
        if self.start >= 0:
            return (None, self)
        
        if self.stop - self.skip < 0:
            return (self, None)
        
        return (Triple(self.start, self.phase, self.skip), Triple(self.phase, self.stop, self.skip))
    
    def sliceBySkip(self, newSkip):
        """
        Returns an iterator over Triples representing the decomposition of self
        into the specified new skip. The new skip must be a multiple of the old
        skip.
        
        >>> list(Triple(None, None, 7, 2).sliceBySkip(21))
        [(*, *, 21, phase=2), (*, *, 21, phase=9), (*, *, 21, phase=16)]
        >>> list(Triple(None, 72, 7).sliceBySkip(21))
        [(*, 86, 21), (*, 79, 21), (*, 72, 21)]
        >>> list(Triple(2, None, 7).sliceBySkip(21))
        [(2, *, 21), (9, *, 21), (16, *, 21)]
        >>> list(Triple(2, 72, 7).sliceBySkip(21))
        [(2, 86, 21), (9, 72, 21), (16, 79, 21)]
        >>> list(Triple(1, 11, 2).sliceBySkip(3))
        Traceback (most recent call last):
          ...
        ValueError: New skip must be a multiple of old skip!
        """
        
        if newSkip % self.skip:
            raise ValueError("New skip must be a multiple of old skip!")
        
        if self.skip == newSkip:
            yield self
        
        else:
            bandCount = newSkip // self.skip
            
            if self.start is None:
                if self.stop is None:
                    phase = self.phase
                    
                    while bandCount:
                        bandCount -= 1
                        yield Triple(None, None, newSkip, phase)
                        phase += self.skip
                
                else:
                    last = self.stop - self.skip
                    
                    while bandCount:
                        bandCount -= 1
                        yield Triple(None, last + newSkip, newSkip)
                        last -= self.skip
            
            elif self.stop is None:
                start = self.start
                
                while bandCount:
                    bandCount -= 1
                    yield Triple(start, None, newSkip)
                    start += self.skip
            
            else:
                start = self.start
                count = bandCount
                d = {}
                last = self.stop - self.skip
                
                while count and last >= start:
                    d[last % newSkip] = last
                    count -= 1
                    last -= self.skip
                
                while bandCount and start < self.stop:
                    bandCount -= 1
                    yield Triple(start, d[start % newSkip] + newSkip, newSkip)
                    start += self.skip
    
    def sub(self, other):
        """
        Returns an iterator of Triples representing the difference of self and
        other (which may be another Triple or a simple integer). This is
        public, and not the __sub__ special method, because it returns an
        iterator and not just a single Triple.

        No particular attempt is made to optimize the return result. A client
        wishing for such optimizations should pass the iterator returned by
        this method into the constructor for the Collection class.
        """
        
        return self.add(-other)
    
    def tripleMax(self, other):
        """
        Returns an iterator over Triples whose values are all the possible
        max() values for all possible (memberOfSelf, memberOfOther) pairs.
        
        >>> list(Triple(50, 100, 25).tripleMax(Triple(1, 21, 2)))
        [(50, 100, 25)]
        >>> list(Triple(1, 21, 2).tripleMax(Triple(50, 100, 25)))
        [(50, 100, 25)]
        >>> list(Triple(None, 40, 6).tripleMax(Triple(20, None, 5)))
        [(22, 40, 6), (20, *, 5)]
        >>> list(Triple(None, None, 15, 4).tripleMax(Triple(None, None, 6, 1)))
        [(*, *, 15, phase=4), (*, *, 6, phase=1)]
        """
        
        if other.start is None:
            yield self
        
        else:
            pieceStart = self.findMember(False, True, other.start)
            
            if pieceStart is not None:
                yield Triple(pieceStart, self.stop, self.skip)
        
        if self.start is None:
            yield other
        
        else:
            pieceStart = other.findMember(False, True, self.start)
            
            if pieceStart is not None:
                yield Triple(pieceStart, other.stop, other.skip)
    
    def tripleMin(self, other):
        """
        Returns an iterator over Triples whose values are all the possible
        min() values for all possible (memberOfSelf, memberOfOther) pairs.
        
        >>> list(Triple(50, 100, 25).tripleMin(Triple(1, 21, 2)))
        [(1, 21, 2)]
        >>> list(Triple(1, 21, 2).tripleMin(Triple(50, 100, 25)))
        [(1, 21, 2)]
        >>> list(Triple(None, 40, 6).tripleMin(Triple(20, None, 5)))
        [(*, 40, 6), (20, 35, 5)]
        >>> list(Triple(None, None, 15, 4).tripleMin(Triple(None, None, 6, 1)))
        [(*, *, 15, phase=4), (*, *, 6, phase=1)]
        """
        
        if other.stop is None:
            yield self
        
        else:
            otherLast = other.stop - other.skip
            pieceLast = self.findMember(True, True, otherLast)
            
            if pieceLast is not None:
                yield Triple(self.start, pieceLast + self.skip, self.skip)
        
        if self.stop is None:
            yield other
        
        else:
            selfLast = self.stop - self.skip
            pieceLast = other.findMember(True, True, selfLast)
            
            if pieceLast is not None:
                yield Triple(other.start, pieceLast + other.skip, other.skip)
    
    def xor(self, other):
        f = self._dispatch['xor']
        
        if f is None:
            self._fillDispatch()
            f = self._dispatch['xor']
        
        return f(self, other)

# -----------------------------------------------------------------------------

#
# Test code
#

if 0:
    def __________________(): pass

def _test():
    import doctest
    doctest.testmod()

if __name__ == "__main__":
    if __debug__:
        _test()

