# #
# # collexper.py
# #
# # Copyright Â© 2015 Monotype Imaging Inc. All Rights Reserved.
# #
# 
# """
# Objects representing spans of integer values similar to those generated by
# the range function, but supporting open ends on one or both sides.
# 
# Collections and Spans serve different purposes, even though both allow open-
# ended components. Spans are for disjoint contiguous groupings of integers,
# while Collections support periodicities. So for example, it's easy to represent
# the values 15...None in both Spans and Collections, but a pseudo-range like
# (11, None, 5) cannot be represented as a Span, while it can very simply be
# represented as a Collection ({1: Span(((2, None, 1),))}, skip=5).
# """
# 
# # System imports
# import collections
# 
# # Other imports
# from fontio3.fontdata import simplemeta
# from fontio3.utilities import span3
# 
# # -----------------------------------------------------------------------------
# 
# #
# # Classes
# #
# 
# class Collection(object):
#     """
#     Dict mapping phases to either span3.Span or (recursively) Collection
#     objects. Note that zero or more of the Spans may be open-ended; it's
#     completely flexible.
#     
#     The Spans here don't collect actual values, but rather normalized values,
#     where normalized = (value - phase) // skip.
#     
#     The following attributes are defined:
#     
#         skip    The common skip for the Collection.
#     """
#     
#     __metaclass__ = mapmeta.FontDataMetaclass
#     
#     mapSpec = dict()
#     
#     attrSpec = dict(
#         d = dict(),
#         skip = dict())
#     
#     attrSorted = ('d', 'skip',)
#     
#     #
#     # Methods
#     #
#     
#     def convertedToSkip(self, newSkip):
#         """
#         Creates and returns a new Collection with the specified newSkip.
#         """
#         
#         r = type(self)({}, skip=newSkip)
#         
#         for phase, sp in self.d.iteritems():
#             pass  # {0: [(22, 52, 3)], 1: [(23, 53, 3)], 2: [(21, 54, 3)], 3: [(22, 52, 3)], 4: [(23, 53, 3)]}
# 
#         
#         return r
#     
#     @classmethod
#     def fromsingles(cls, it):
#         """
#         Creates and returns a new Collection from the single values yielded by
#         the specified iterator.
#         
#         >>> print(Collection.fromsingles({3, 5, 7, 9}))
#         {0: 3, 5, 7, or 9}, skip = 1
#         """
#         
#         sp = span3.Span.fromsingles(it)
#         return cls({0: sp}, skip=1)
#     
# # -----------------------------------------------------------------------------
# 
# #
# # Test code
# #
# 
# if 0:
#     def __________________(): pass
# 
# def _test():
#     import doctest
#     doctest.testmod()
# 
# if __name__ == "__main__":
#     if __debug__:
#         _test()

